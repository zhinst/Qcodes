
Implementing doND using the dataset
===================================

.. code:: ipython3

    from functools import partial
    
    import numpy as np
    
    from qcodes.dataset.database import initialise_database
    from qcodes.dataset.experiment_container import new_experiment
    from qcodes.tests.instrument_mocks import DummyInstrument
    from qcodes.dataset.measurements import Measurement
    from qcodes.dataset.plotting import plot_by_id

.. code:: ipython3

    initialise_database()  # just in case no database file exists
    new_experiment("doNd-tutorial", sample_name="no sample")




.. parsed-literal::

    doNd-tutorial#no sample#10@./exp_container_tutorial.db
    ------------------------------------------------------



First we borrow the dummy instruments from the contextmanager notebook
to have something to measure.

.. code:: ipython3

    # preparatory mocking of physical setup
    
    dac = DummyInstrument('dac', gates=['ch1', 'ch2'])
    dmm = DummyInstrument('dmm', gates=['v1', 'v2'])

.. code:: ipython3

    # and we'll make a 2D gaussian to sample from/measure
    def gauss_model(x0: float, y0: float, sigma: float, noise: float=0.0005):
        """
        Returns a generator sampling a gaussian. The gaussian is
        normalised such that its maximal value is simply 1
        """
        while True:
            (x, y) = yield
            model = np.exp(-((x0-x)**2+(y0-y)**2)/2/sigma**2)*np.exp(2*sigma**2)
            noise = np.random.randn()*noise
            yield model + noise

.. code:: ipython3

    # and finally wire up the dmm v1 to "measure" the gaussian
    
    gauss = gauss_model(0.1, 0.2, 0.25)
    next(gauss)
    
    def measure_gauss(dac):
        val = gauss.send((dac.ch1.get(), dac.ch2.get()))
        next(gauss)
        return val
    
    dmm.v1.get = partial(measure_gauss, dac)

Now lets reimplement the qdev-wrapper do1d function that can measure one
one more parameters as a function of another parameter. This is more or
less as simple as you would expect.

.. code:: ipython3

    def do1d(param_set, start, stop, num_points, delay, *param_meas):
        meas = Measurement()
        meas.register_parameter(param_set)  # register the first independent parameter
        output = [] 
        param_set.post_delay = delay
        # do1D enforces a simple relationship between measured parameters
        # and set parameters. For anything more complicated this should be reimplemented from scratch
        for parameter in param_meas:
            meas.register_parameter(parameter, setpoints=(param_set,))
            output.append([parameter, None])
    
        with meas.run() as datasaver:
            for set_point in np.linspace(start, stop, num_points):
                param_set.set(set_point)
                for i, parameter in enumerate(param_meas):
                    output[i][1] = parameter.get()
                datasaver.add_result((param_set, set_point),
                                     *output)
        dataid = datasaver.run_id  # convenient to have for plotting
        return dataid

.. code:: ipython3

    dataid = do1d(dac.ch1, 0, 1, 10, 0.01, dmm.v1, dmm.v2)


.. parsed-literal::

    Starting experimental run with id: 45


.. code:: ipython3

    axes, cbaxes = plot_by_id(dataid)



.. image:: Implementing_doND_using_the_dataset_files/Implementing_doND_using_the_dataset_10_0.png



.. image:: Implementing_doND_using_the_dataset_files/Implementing_doND_using_the_dataset_10_1.png


.. code:: ipython3

    def do2d(param_set1, start1, stop1, num_points1, delay1, 
             param_set2, start2, stop2, num_points2, delay2,
             *param_meas):
        # And then run an experiment
    
        meas = Measurement()
        meas.register_parameter(param_set1)
        param_set1.post_delay = delay1
        meas.register_parameter(param_set2)
        param_set1.post_delay = delay2
        output = [] 
        for parameter in param_meas:
            meas.register_parameter(parameter, setpoints=(param_set1,param_set2))
            output.append([parameter, None])
    
        with meas.run() as datasaver:
            for set_point1 in np.linspace(start1, stop1, num_points1):
                param_set1.set(set_point1)
                for set_point2 in np.linspace(start2, stop2, num_points2):
                    param_set2.set(set_point2)
                    for i, parameter in enumerate(param_meas):
                        output[i][1] = parameter.get()
                    datasaver.add_result((param_set1, set_point1),
                                         (param_set2, set_point2),
                                         *output)
        dataid = datasaver.run_id  # convenient to have for plotting
        return dataid

.. code:: ipython3

    dataid = do2d(dac.ch1, -1, 1, 100, 0.01, 
                         dac.ch2, -1, 1, 100, 0.01, 
                         dmm.v1, dmm.v2)


.. parsed-literal::

    Starting experimental run with id: 46


.. code:: ipython3

    axes, cbaxes = plot_by_id(dataid)



.. image:: Implementing_doND_using_the_dataset_files/Implementing_doND_using_the_dataset_13_0.png



.. image:: Implementing_doND_using_the_dataset_files/Implementing_doND_using_the_dataset_13_1.png


