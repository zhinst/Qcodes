
Creating QCoDeS instrument drivers
==================================

.. code:: ipython3

    # most of the drivers only need a couple of these... moved all up here for clarity below
    from time import sleep, time
    import numpy as np
    import ctypes  # only for DLL-based instrument
    
    import qcodes as qc
    from qcodes import (Instrument, VisaInstrument,
                        ManualParameter, MultiParameter,
                        validators as vals)
    from qcodes.instrument.channel import InstrumentChannel

Base Classes
------------

There are 3 available: - ``VisaInstrument`` - for most instruments that
communicate over a text channel (ethernet, GPIB, serial, USB...) that do
not have a custom DLL or other driver to manage low-level commands. -
``IPInstrument`` - a deprecated driver just for ethernet connections. Do
not use this; use ``VisaInstrument`` instead. - ``Instrument`` -
superclass of both ``VisaInstrument`` and ``IPInstrument``, use this if
you do not communicate over a text channel, for example: - PCI cards
with their own DLLs - Instruments with only manual controls.

If possible, please use a ``VisaInstrument``, as this allows for the
creation of a simulated instrument. (See the
``Creating Simulated PyVISA Instruments`` notebook)

Parameters and Channels
-----------------------

Broadly speaking, a QCoDeS instrument driver is nothing but an object
that holds a connection handle to the physical instrument and has some
sub-objects that represent the state of the physical instrument. These
sub-objects are the ``Parameters``. Writing a driver basically boils
down to adding a ton of ``Parameters``.

What's a Parameter?
~~~~~~~~~~~~~~~~~~~

A parameter represents a single value of a single feature of an
instrument, e.g. the frequency of a function generator, the mode of a
multimeter (resistance, current, or voltage), or the input impedance of
an oscilloscope channel. Each ``Parameter`` can have the following
attributes:

-  ``name``, the name used internally by QCoDeS, e.g. 'input\_impedance'
-  ``label``, the label to use for plotting this parameter
-  ``unit``, the physical unit. ALWAYS use SI units if a unit is
   applicable
-  ``set_cmd``, the command to set the parameter. Either a SCPI string
   with a single '{}', or a function taking one argument (see examples
   below)
-  ``get_cmd``, the command to get the parameter. Follows the same
   scheme as ``set_cmd``
-  ``vals``, a validator (from ``qcodes.utils.validators``) to reject
   invalid values before they are sent to the instrument. Since there is
   no standard for how an instrument responds to an out-of-bound value
   (e.g. a 10 kHz function generator receiving 12e9 for its frequency),
   meaning that the user can expect anything from silent failure to the
   instrument breaking or suddenly outputting random noise, it is MUCH
   better to catch invalid values in software. Therefore, please provide
   a validator if at all possible.
-  ``val_mapping``, a dictionary mapping human-readable values like
   'High Impedance' to the instrument's internal representation like
   '372'. Not always needed. If supplied, a validator is automatically
   constructed.
-  ``get_parser``, a parser of the raw return value. Since all VISA
   instruments return strings, but users usually want numbers, ``int``
   and ``float`` are popular ``get_parsers``

Golden rule: if a ``Parameter`` is settable, it must always accept its
own output as input.

What's a Channel, then?
~~~~~~~~~~~~~~~~~~~~~~~

A ``Channel`` is a submodule holding ``Parameter``\ s. It sometimes
makes sense to group ``Parameter``\ s, for instance when an oscilloscope
has four identical input channels. (see Keithley example below)

VisaInstrument: Simple example
------------------------------

The Weinschel 8320 driver is about as basic a driver as you can get. It
only defines one parameter, "attenuation". All the comments here are my
additions to describe what's happening.

.. code:: ipython3

    class Weinschel_8320(VisaInstrument):
        """
        QCoDeS driver for the stepped attenuator
        Weinschel is formerly known as Aeroflex/Weinschel
        """
    
        # all instrument constructors should accept **kwargs and pass them on to
        # super().__init__
        def __init__(self, name, address, **kwargs):
            # supplying the terminator means you don't need to remove it from every response
            super().__init__(name, address, terminator='\r', **kwargs)
    
            self.add_parameter('attenuation', unit='dB',
                               # the value you set will be inserted in this command with
                               # regular python string substitution. This instrument wants
                               # an integer zero-padded to 2 digits. For robustness, don't
                               # assume you'll get an integer input though - try to allow
                               # floats (as opposed to {:0=2d})
                               set_cmd='ATTN ALL {:02.0f}',
                               get_cmd='ATTN? 1',
                               # setting any attenuation other than 0, 2, ... 60 will error.
                               vals=vals.Enum(*np.arange(0, 60.1, 2).tolist()),
                               # the return value of get() is a string, but we want to
                               # turn it into a (float) number
                               get_parser=float)
    
            # it's a good idea to call connect_message at the end of your constructor.
            # this calls the 'IDN' parameter that the base Instrument class creates for
            # every instrument (you can override the `get_idn` method if it doesn't work
            # in the standard VISA form for your instrument) which serves two purposes:
            # 1) verifies that you are connected to the instrument
            # 2) gets the ID info so it will be included with metadata snapshots later.
            self.connect_message()
    
    # instantiating and using this instrument (commented out because I can't actually do it!)
    #
    # from qcodes.instrument_drivers.weinschel.Weinschel_8320 import Weinschel_8320
    # weinschel = Weinschel_8320('w8320_1', 'TCPIP0::172.20.2.212::inst0::INSTR')
    # weinschel.attenuation(40)

VisaInstrument: a more involved example
---------------------------------------

The Keithley 2600 sourcemeter driver uses two channels. The actual
driver is quite long, so here we show an abridged version that has:

-  A class defining a ``Channel``. All the ``Parameter``\ s of the
   ``Channel`` go here.
-  A nifty way to look up the model number, allowing it to be a driver
   for many different Keithley models

.. code:: ipython3

    class KeithleyChannel(InstrumentChannel):
        """
        Class to hold the two Keithley channels, i.e.
        SMUA and SMUB.
        """
    
        def __init__(self, parent: Instrument, name: str, channel: str) -> None:
            """
            Args:
                parent: The Instrument instance to which the channel is
                    to be attached.
                name: The 'colloquial' name of the channel
                channel: The name used by the Keithley, i.e. either
                    'smua' or 'smub'
            """
    
            if channel not in ['smua', 'smub']:
                raise ValueError('channel must be either "smub" or "smua"')
    
            super().__init__(parent, name)
            self.model = self._parent.model
            vranges = self._parent._vranges
            iranges = self._parent._iranges
    
            self.add_parameter('volt',
                               get_cmd='{}.measure.v()'.format(channel),
                               get_parser=float,
                               set_cmd='{}.source.levelv={}'.format(channel,
                                                                    '{:.12f}'),
                               # note that the set_cmd is either the following format string
                               #'smua.source.levelv={:.12f}' or 'smub.source.levelv={:.12f}' 
                               # depending on the value of `channel`
                               label='Voltage',
                               unit='V')
    
            self.add_parameter('curr',
                               get_cmd='{}.measure.i()'.format(channel),
                               get_parser=float,
                               set_cmd='{}.source.leveli={}'.format(channel,
                                                                    '{:.12f}'),
                               label='Current',
                               unit='A')
    
            self.add_parameter('mode',
                               get_cmd='{}.source.func'.format(channel),
                               get_parser=float,
                               set_cmd='{}.source.func={}'.format(channel, '{:d}'),
                               val_mapping={'current': 0, 'voltage': 1},
                               docstring='Selects the output source.')
    
            self.add_parameter('output',
                               get_cmd='{}.source.output'.format(channel),
                               get_parser=float,
                               set_cmd='{}.source.output={}'.format(channel,
                                                                    '{:d}'),
                               val_mapping={'on':  1, 'off': 0})
    
            self.add_parameter('nplc',
                               label='Number of power line cycles',
                               set_cmd='{}.measure.nplc={}'.format(channel,
                                                                   '{:.4f}'),
                               get_cmd='{}.measure.nplc'.format(channel),
                               get_parser=float,
                               vals=vals.Numbers(0.001, 25))
           
    
            self.channel = channel
            
            
    class Keithley_2600(VisaInstrument):
        """
        This is the qcodes driver for the Keithley_2600 Source-Meter series,
        tested with Keithley_2614B
        """
        def __init__(self, name: str, address: str, **kwargs) -> None:
            """
            Args:
                name: Name to use internally in QCoDeS
                address: VISA ressource address
            """
            super().__init__(name, address, terminator='\n', **kwargs)
    
            model = self.ask('localnode.model')
    
            knownmodels = ['2601B', '2602B', '2604B', '2611B', '2612B',
                           '2614B', '2635B', '2636B']
            if model not in knownmodels:
                kmstring = ('{}, '*(len(knownmodels)-1)).format(*knownmodels[:-1])
                kmstring += 'and {}.'.format(knownmodels[-1])
                raise ValueError('Unknown model. Known model are: ' + kmstring)
                
            # Add the channel to the instrument
            for ch in ['a', 'b']:
                ch_name = 'smu{}'.format(ch)
                channel = KeithleyChannel(self, ch_name, ch_name)
                self.add_submodule(ch_name, channel)
    
            # display parameter
            # Parameters NOT specific to a channel still belong on the Instrument object
            # In this case, the Parameter controls the text on the display
            self.add_parameter('display_settext',
                               set_cmd=self._display_settext,
                               vals=vals.Strings())
    
            self.connect_message()

VisaInstruments: Simulating the instrument
------------------------------------------

As mentioned above, drivers subclassing ``VisaInstrument`` have the nice
property that they may be connected to a simulated version of the
physical instrument. See the ``Creating Simulated PyVISA Instruments``
notebook for more information. If you are writing a ``VisaInstrument``
driver, please consider spending 20 minutes to also add a simulated
instrument and a test.

DLL-based instruments
---------------------

The Alazar cards use their own DLL. C interfaces tend to need a lot of
boilerplate, so I'm not going to include it all. The key is: use
``Instrument`` directly, load the DLL, and have parameters interact with
it.

.. code:: ipython3

    class AlazarTech_ATS(Instrument):
        dll_path = 'C:\\WINDOWS\\System32\\ATSApi'
        def __init__(self, name, system_id=1, board_id=1, dll_path=None, **kwargs):
            super().__init__(name, **kwargs)
            
            # connect to the DLL
            self._ATS_dll = ctypes.cdll.LoadLibrary(dll_path or self.dll_path)
    
            self._handle = self._ATS_dll.AlazarGetBoardBySystemID(system_id,
                                                                  board_id)
            if not self._handle:
                raise Exception('AlazarTech_ATS not found at '
                                'system {}, board {}'.format(system_id, board_id))
    
            self.buffer_list = []
            
            # the Alazar driver includes its own parameter class to hold values
            # until later config is called, and warn if you try to read a value
            # that hasn't been sent to config.
            self.add_parameter(name='clock_source',
                               parameter_class=AlazarParameter,
                               label='Clock Source',
                               unit=None,
                               value='INTERNAL_CLOCK',
                               byte_to_value_dict={1: 'INTERNAL_CLOCK',
                                                   4: 'SLOW_EXTERNAL_CLOCK',
                                                   5: 'EXTERNAL_CLOCK_AC',
                                                   7: 'EXTERNAL_CLOCK_10_MHz_REF'})
            
            # etc...

Manual instruments
------------------

A totally manual instrument (like the ithaco 1211) will contain only
``ManualParameter``\ s. Some instruments may have a mix of manual and
standard parameters. Here we also define a new ``CurrentParameter``
class that uses the ithaco parameters to convert a measured voltage to a
current. When subclassing a parameter class (``Parameter``,
``MultiParameter``, ...), the functions for setting and getting should
be called ``get_raw`` and ``set_raw``, respectively.

.. code:: ipython3

    class CurrentParameter(MultiParameter):
        """
        Current measurement via an Ithaco preamp and a measured voltage.
    
        To be used when you feed a current into the Ithaco, send the Ithaco's
        output voltage to a lockin or other voltage amplifier, and you have
        the voltage reading from that amplifier as a qcodes parameter.
    
        ``CurrentParameter.get()`` returns ``(voltage_raw, current)``
    
        Args:
            measured_param (Parameter): a gettable parameter returning the
                voltage read from the Ithaco output.
    
            c_amp_ins (Ithaco_1211): an Ithaco instance where you manually
                maintain the present settings of the real Ithaco amp.
    
            name (str): the name of the current output. Default 'curr'.
                Also used as the name of the whole parameter.
        """
        def __init__(self, measured_param, c_amp_ins, name='curr'):
            p_name = measured_param.name
    
            p_label = getattr(measured_param, 'label', None)
            p_unit = getattr(measured_param, 'units', None)
    
            super().__init__(name=name, names=(p_name+'_raw', name),
                             shapes=((), ()),
                             labels=(p_label, 'Current'),
                             units=(p_unit, 'A'))
    
            self._measured_param = measured_param
            self._instrument = c_amp_ins
    
        def get_raw(self):
            volt = self._measured_param.get()
            current = (self._instrument.sens.get() *
                       self._instrument.sens_factor.get()) * volt
    
            if self._instrument.invert.get():
                current *= -1
    
            value = (volt, current)
            self._save_val(value)
            return value
    
    
    class Ithaco_1211(Instrument):
        """
        This is the qcodes driver for the Ithaco 1211 Current-preamplifier.
    
        This is a virtual driver only and will not talk to your instrument.
        """
        def __init__(self, name, **kwargs):
            super().__init__(name, **kwargs)
    
            # ManualParameter has an "initial_value" kwarg, but if you use this
            # you must be careful to check that it's correct before relying on it.
            # if you don't set initial_value, it will start out as None.
            self.add_parameter('sens',
                               parameter_class=ManualParameter,
                               initial_value=1e-8,
                               label='Sensitivity',
                               units='A/V',
                               vals=vals.Enum(1e-11, 1e-10, 1e-09, 1e-08, 1e-07,
                                              1e-06, 1e-05, 1e-4, 1e-3))
    
            self.add_parameter('invert',
                               parameter_class=ManualParameter,
                               initial_value=True,
                               label='Inverted output',
                               vals=vals.Bool())
    
            self.add_parameter('sens_factor',
                               parameter_class=ManualParameter,
                               initial_value=1,
                               label='Sensitivity factor',
                               units=None,
                               vals=vals.Enum(0.1, 1, 10))
    
            self.add_parameter('suppression',
                               parameter_class=ManualParameter,
                               initial_value=1e-7,
                               label='Suppression',
                               units='A',
                               vals=vals.Enum(1e-10, 1e-09, 1e-08, 1e-07, 1e-06,
                                              1e-05, 1e-4, 1e-3))
    
            self.add_parameter('risetime',
                               parameter_class=ManualParameter,
                               initial_value=0.3,
                               label='Rise Time',
                               units='msec',
                               vals=vals.Enum(0.01, 0.03, 0.1, 0.3, 1, 3, 10, 30,
                                              100, 300, 1000))
    
        def get_idn(self):
            return {'vendor': 'Ithaco (DL Instruments)', 'model': '1211',
                    'serial': None, 'firmware': None}

Custom Parameter classes
------------------------

When you call:

::

    self.add_parameter(name, **kwargs)

you create a ``Parameter``. But with the ``parameter_class`` kwarg you
can invoke any class you want:

::

    self.add_parameter(name, parameter_class=OtherClass, **kwargs)

-  ``Parameter`` handles most common instrument settings and
   measurements.
-  Accepts get and/or set commands as either strings for the
   instrument's ``ask`` and ``write`` methods, or functions/methods. The
   set and get commands may also be set to ``False`` and ``None``.
   ``False`` corresponds to "no get/set method available" (example: the
   reading of a voltmeter is not settable, so we set ``set_cmd=False``).
   ``None`` corresponds to a manually updated parameter (example: an
   instrument with no remote interface).
-  Has options for translating between instrument codes and more
   meaningful data values
-  Supports software-controlled ramping
-  Any other parameter class may be used in ``add_parameter``, if it
   accepts ``name`` and ``instrument`` as constructor kwargs. Generally
   these should subclass ``Parameter``, ``ArrayParameter``, or
   ``MultiParameter``.

Dynamically adding and removing parameters
------------------------------------------

Sometimes when conditions change (for example, the mode of operation of
the instrument is changed from current to voltage measurement) you want
different parameters to be available.

To delete existing parameters:

::

    del self.parameters[name_to_delete]

And to add more, do the same thing as you did initially:

::

    self.add_parameter(new_name, **kwargs)

Organization
------------

Your drivers do not need to be part of QCoDeS in order to use them with
QCoDeS, but we strongly encourage you to contribute them to the project.
That way we prevent duplication of effort, and you will likely get help
making the driver better, with more features and better code.

Make one driver per module, inside a directory named for the company (or
institution), within the ``instrument_drivers`` directory, following the
convention:

``instrument_drivers.<company>.<model>.<company>_<model>`` - example:
``instrument_drivers.AlazarTech.ATS9870.AlazarTech_ATS9870``

Although the class name can be just the model if it is globally
unambiguous. For example: - example:
``instrument_drivers.stanford_research.SR560.SR560``

And note that due to mergers, some drivers may not be in the folder you
expect: - example:
``instrument_drivers.tektronix.Keithley_2600.Keithley_2600_Channels``

