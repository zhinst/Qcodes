

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>qcodes.instrument.parameter &mdash; QCoDeS 0.5.2+232.gd7245f51c documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href="../../../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> QCoDeS
          

          
          </a>

          
            
            
              <div class="version">
                0.5.2+232.gd7245f51c
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../start/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../help.html">Get Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../community/index.html">Community Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dataset/index.html">DataSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">QCoDes API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/generated/qcodes.instrument_drivers.html">qcodes.instrument_drivers package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changes/index.html">Changelogs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples of using QCoDeS</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">QCoDeS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>qcodes.instrument.parameter</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for qcodes.instrument.parameter</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The Parameter module implements Parameter interface</span>
<span class="sd">that are the basis of measurements and control within QCoDeS.</span>

<span class="sd">Anything that you want to either measure or control within QCoDeS should</span>
<span class="sd">satisfy the Parameter interface. Most of the time that is easiest to do</span>
<span class="sd">by either using or subclassing one of the classes defined here, but you can</span>
<span class="sd">also use any class with the right attributes.</span>

<span class="sd">All parameter classes are subclassed from ``._BaseParameter`` (except</span>
<span class="sd">CombinedParameter). The _BaseParameter provides functionality that is common</span>
<span class="sd">to all parameter types, such as ramping and scaling of values, adding delays</span>
<span class="sd">(see documentation for details).</span>

<span class="sd">This module defines the following basic classes of parameters as well as some</span>
<span class="sd">more specialized ones:</span>

<span class="sd">- :class:`.Parameter` is the base class for scalar-valued parameters.</span>
<span class="sd">    Two primary ways in which it can be used:</span>

<span class="sd">    1. As an :class:`.Instrument` parameter that sends/receives commands.</span>
<span class="sd">       Provides a standardized interface to construct strings to pass to the</span>
<span class="sd">       :meth:`.Instrument.write` and :meth:`.Instrument.ask` methods</span>
<span class="sd">    2. As a variable that stores and returns a value. For instance, for storing</span>
<span class="sd">       of values you want to keep track of but cannot set or get electronically.</span>

<span class="sd">- :class:`.ParameterWithSetpoints` is intended for array-values parameters.</span>
<span class="sd">    This Parameter class is intended for anything where a call to the instrument</span>
<span class="sd">    returns an array of values.</span>
<span class="sd">    `This notebook &lt;../examples/writing_drivers/Simple-Example-of-ParameterWithSetpoints.ipynb&gt;`_.</span>
<span class="sd">    gives more detailed examples of how this parameter can be used.</span>
<span class="sd">    :class:`.ParameterWithSetpoints` is supported in a</span>
<span class="sd">    :class:`qcodes.dataset.measurements.Measurement` but is not supported by the</span>
<span class="sd">    legacy :class:`qcodes.loops.Loop` and :class:`qcodes.measure.Measure`</span>
<span class="sd">    measurement types.</span>

<span class="sd">- :class:`.DelegateParameter` is intended proxy-ing other parameters.</span>
<span class="sd">    It forwards its ``get`` and ``set`` to the underlying source parameter,</span>
<span class="sd">    while allowing to specify label/unit/etc that is different from the</span>
<span class="sd">    source parameter.</span>

<span class="sd">- :class:`.ArrayParameter` is an older base class for array-valued parameters.</span>
<span class="sd">    For any new driver we strongly recommend using</span>
<span class="sd">    :class:`.ParameterWithSetpoints` which is both more flexible and</span>
<span class="sd">    significantly easier to use. This Parameter is intended for anything for</span>
<span class="sd">    which each ``get`` call returns an array of values that all have the same</span>
<span class="sd">    type and meaning. Currently not settable, only gettable. Can be used in a</span>
<span class="sd">    :class:`qcodes.dataset.measurements.Measurement`</span>
<span class="sd">    as well as in the legacy :class:`qcodes.loops.Loop`</span>
<span class="sd">    and :class:`qcodes.measure.Measure` measurements - in which case</span>
<span class="sd">    these arrays are nested inside the loop&#39;s setpoint array. To use, provide a</span>
<span class="sd">    ``get`` method that returns an array or regularly-shaped sequence, and</span>
<span class="sd">    describe that array in ``super().__init__``.</span>

<span class="sd">- :class:`.MultiParameter` is the base class for multi-valued parameters.</span>
<span class="sd">    Currently not settable, only gettable, but can return an arbitrary</span>
<span class="sd">    collection of scalar and array values and can be used in</span>
<span class="sd">    :class:`qcodes.dataset.measurements.Measurement` as well as the</span>
<span class="sd">    legacy :class:`qcodes.loops.Loop` and :class:`qcodes.measure.Measure`</span>
<span class="sd">    measurements. To use, provide a ``get`` method</span>
<span class="sd">    that returns a sequence of values, and describe those values in</span>
<span class="sd">    ``super().__init__``.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># TODO (alexcjohnson) update this with the real duck-typing requirements or</span>
<span class="c1"># create an ABC for Parameter and MultiParameter - or just remove this statement</span>
<span class="c1"># if everyone is happy to use these classes.</span>

<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">xor</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> \
    <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">qcodes.utils.helpers</span> <span class="k">import</span> <span class="n">abstractmethod</span>

<span class="kn">from</span> <span class="nn">qcodes.utils.helpers</span> <span class="k">import</span> <span class="p">(</span><span class="n">permissive_range</span><span class="p">,</span> <span class="n">is_sequence_of</span><span class="p">,</span>
                                  <span class="n">DelegateAttributes</span><span class="p">,</span> <span class="n">full_class</span><span class="p">,</span> <span class="n">named_repr</span><span class="p">,</span>
                                  <span class="n">warn_units</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">qcodes.utils.metadata</span> <span class="k">import</span> <span class="n">Metadatable</span>
<span class="kn">from</span> <span class="nn">qcodes.utils.command</span> <span class="k">import</span> <span class="n">Command</span>
<span class="kn">from</span> <span class="nn">qcodes.utils.validators</span> <span class="k">import</span> <span class="n">Validator</span><span class="p">,</span> <span class="n">Ints</span><span class="p">,</span> <span class="n">Strings</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Arrays</span>
<span class="kn">from</span> <span class="nn">qcodes.instrument.sweep_values</span> <span class="k">import</span> <span class="n">SweepFixedValues</span>
<span class="kn">from</span> <span class="nn">qcodes.data.data_array</span> <span class="k">import</span> <span class="n">DataArray</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">Instrument</span><span class="p">,</span> <span class="n">InstrumentBase</span>

<span class="n">Number</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="c1"># for now the type the parameter may contain is not restricted at all</span>
<span class="n">ParamDataType</span> <span class="o">=</span> <span class="n">Any</span>


<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_SetParamContext</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is returned by the ``set_to`` method of parameters</span>

<span class="sd">    Example usage:</span>

<span class="sd">    &gt;&gt;&gt; v = dac.voltage()</span>
<span class="sd">    &gt;&gt;&gt; with dac.voltage.set_to(-1):</span>
<span class="sd">        ...     # Do stuff with the DAC output set to -1 V.</span>
<span class="sd">        ...</span>
<span class="sd">    &gt;&gt;&gt; assert abs(dac.voltage() - v) &lt;= tolerance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span> <span class="o">=</span> <span class="n">parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">_latest</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_value</span><span class="p">)</span>


<div class="viewcode-block" id="invert_val_mapping"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.invert_val_mapping">[docs]</a><span class="k">def</span> <span class="nf">invert_val_mapping</span><span class="p">(</span><span class="n">val_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Inverts the value mapping dictionary for allowed parameter values&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<span class="k">class</span> <span class="nc">_BaseParameter</span><span class="p">(</span><span class="n">Metadatable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shared behavior for all parameters. Not intended to be used</span>
<span class="sd">    directly, normally you should use ``Parameter``, ``ArrayParameter``,</span>
<span class="sd">    ``MultiParameter``, or ``CombinedParameter``.</span>
<span class="sd">    Note that ``CombinedParameter`` is not yet a subclass of ``_BaseParameter``</span>

<span class="sd">    Args:</span>
<span class="sd">        name: the local name of the parameter. Must be a valid</span>
<span class="sd">            identifier, ie no spaces or special characters or starting with a</span>
<span class="sd">            number. If this parameter is part of an Instrument or Station,</span>
<span class="sd">            this should match how it will be referenced from that parent,</span>
<span class="sd">            ie ``instrument.name`` or ``instrument.parameters[name]``</span>

<span class="sd">        instrument: the instrument this parameter</span>
<span class="sd">            belongs to, if any</span>

<span class="sd">        snapshot_get: False prevents any update to the</span>
<span class="sd">            parameter during a snapshot, even if the snapshot was called with</span>
<span class="sd">            ``update=True``, for example if it takes too long to update.</span>
<span class="sd">            Default True.</span>

<span class="sd">        snapshot_value (Optional[bool]): False prevents parameter value to be</span>
<span class="sd">            stored in the snapshot. Useful if the value is large.</span>

<span class="sd">        snapshot_exclude (Optional[bool]): True prevents parameter to be</span>
<span class="sd">            included in the snapshot. Useful if there are many of the same</span>
<span class="sd">            parameter which are clogging up the snapshot.</span>
<span class="sd">            Default False</span>

<span class="sd">        step (Optional[Union[int, float]]): max increment of parameter value.</span>
<span class="sd">            Larger changes are broken into multiple steps this size.</span>
<span class="sd">            When combined with delays, this acts as a ramp.</span>

<span class="sd">        scale (Optional[float]): Scale to multiply value with before</span>
<span class="sd">            performing set. the internally multiplied value is stored in</span>
<span class="sd">            `raw_value`. Can account for a voltage divider.</span>

<span class="sd">        offset: Compensate for a parameter specific offset. (just as scale)</span>
<span class="sd">            get value = raw value - offset.</span>
<span class="sd">            set value = argument + offset.</span>
<span class="sd">            If offset and scale are used in combination, when getting a value,</span>
<span class="sd">            first an offset is added, then the scale is applied.</span>

<span class="sd">        inter_delay (Optional[Union[int, float]]): Minimum time (in seconds)</span>
<span class="sd">            between successive sets. If the previous set was less than this,</span>
<span class="sd">            it will wait until the condition is met.</span>
<span class="sd">            Can be set to 0 to go maximum speed with no errors.</span>

<span class="sd">        post_delay (Optional[Union[int, float]]): time (in seconds) to wait</span>
<span class="sd">            after the *start* of each set, whether part of a sweep or not.</span>
<span class="sd">            Can be set to 0 to go maximum speed with no errors.</span>

<span class="sd">        val_mapping (Optional[dict]): a bidirectional map data/readable values</span>
<span class="sd">            to instrument codes, expressed as a dict:</span>
<span class="sd">            ``{data_val: instrument_code}``</span>
<span class="sd">            For example, if the instrument uses &#39;0&#39; to mean 1V and &#39;1&#39; to mean</span>
<span class="sd">            10V, set val_mapping={1: &#39;0&#39;, 10: &#39;1&#39;} and on the user side you</span>
<span class="sd">            only see 1 and 10, never the coded &#39;0&#39; and &#39;1&#39;</span>
<span class="sd">            If vals is omitted, will also construct a matching Enum validator.</span>
<span class="sd">            NOTE: only applies to get if get_cmd is a string, and to set if</span>
<span class="sd">            set_cmd is a string.</span>
<span class="sd">            You can use ``val_mapping`` with ``get_parser``, in which case</span>
<span class="sd">            ``get_parser`` acts on the return value from the instrument first,</span>
<span class="sd">            then ``val_mapping`` is applied (in reverse).</span>

<span class="sd">        get_parser ( Optional[Callable]): function to transform the response</span>
<span class="sd">            from get to the final output value. See also val_mapping</span>

<span class="sd">        set_parser (Optional[Callable]): function to transform the input set</span>
<span class="sd">            value to an encoded value sent to the instrument.</span>
<span class="sd">            See also val_mapping.</span>

<span class="sd">        vals (Optional[Validator]): a Validator object for this parameter</span>

<span class="sd">        max_val_age (Optional[float]): The max time (in seconds) to trust a</span>
<span class="sd">            saved value obtained from get_latest(). If this parameter has not</span>
<span class="sd">            been set or measured more recently than this, perform an</span>
<span class="sd">            additional measurement.</span>

<span class="sd">        metadata (Optional[dict]): extra information to include with the</span>
<span class="sd">            JSON snapshot of the parameter</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">instrument</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Instrument&#39;</span><span class="p">],</span>
                 <span class="n">snapshot_get</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">]]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">]]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">inter_delay</span><span class="p">:</span> <span class="n">Number</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">post_delay</span><span class="p">:</span> <span class="n">Number</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">val_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">get_parser</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">set_parser</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">snapshot_value</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">snapshot_exclude</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">max_val_age</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">vals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Validator</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Parameter name must be a valid identifier &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;got </span><span class="si">{name}</span><span class="s2"> which is not. Parameter names &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;cannot start with a number and &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;must not contain spaces or special characters&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">short_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span> <span class="o">=</span> <span class="n">instrument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_get</span> <span class="o">=</span> <span class="n">snapshot_get</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_value</span> <span class="o">=</span> <span class="n">snapshot_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_exclude</span> <span class="o">=</span> <span class="n">snapshot_exclude</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">(</span><span class="n">Validator</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;vals must be None or a Validator&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">val_mapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="o">*</span><span class="n">val_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_value</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span> <span class="o">=</span> <span class="n">inter_delay</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_delay</span> <span class="o">=</span> <span class="n">post_delay</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">val_mapping</span> <span class="o">=</span> <span class="n">val_mapping</span>
        <span class="k">if</span> <span class="n">val_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span> <span class="o">=</span> <span class="n">invert_val_mapping</span><span class="p">(</span><span class="n">val_mapping</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">get_parser</span> <span class="o">=</span> <span class="n">get_parser</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_parser</span> <span class="o">=</span> <span class="n">set_parser</span>

        <span class="c1"># record of latest value and when it was set or measured</span>
        <span class="c1"># what exactly this means is different for different subclasses</span>
        <span class="c1"># but they all use the same attributes so snapshot is consistent.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_latest</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ParamDataType</span><span class="p">,</span> <span class="n">datetime</span><span class="p">]]]</span> <span class="o">=</span> \
            <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;ts&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;raw_value&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_latest</span> <span class="o">=</span> <span class="n">GetLatest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_val_age</span><span class="o">=</span><span class="n">max_val_age</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get_raw&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_raw</span><span class="p">,</span> <span class="s1">&#39;__qcodes_is_abstract_method__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_raw</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Wrapping get method of parameter: </span><span class="si">{self.full_name}</span><span class="s1">,&#39;</span>
                          <span class="n">f</span><span class="s1">&#39; original get method will not &#39;</span>
                          <span class="n">f</span><span class="s1">&#39;be directly accessible. It is recommended to &#39;</span>
                          <span class="n">f</span><span class="s1">&#39;define get_raw in your subclass instead. &#39;</span>
                          <span class="n">f</span><span class="s1">&#39;Overwriting get will be an error in the future.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;set_raw&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_raw</span><span class="p">,</span> <span class="s1">&#39;__qcodes_is_abstract_method__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_raw</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Wrapping set method of parameter: </span><span class="si">{self.full_name}</span><span class="s1">, &#39;</span>
                          <span class="n">f</span><span class="s1">&#39;original set method will not &#39;</span>
                          <span class="n">f</span><span class="s1">&#39;be directly accessible. It is recommended to &#39;</span>
                          <span class="n">f</span><span class="s1">&#39;define set_raw in your subclass instead. &#39;</span>
                          <span class="n">f</span><span class="s1">&#39;Overwriting set will be an error in the future.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">)</span>

        <span class="c1"># subclasses should extend this list with extra attributes they</span>
        <span class="c1"># want automatically included in the snapshot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;instrument&#39;</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;inter_delay&#39;</span><span class="p">,</span> <span class="s1">&#39;post_delay&#39;</span><span class="p">,</span> <span class="s1">&#39;val_mapping&#39;</span><span class="p">,</span> <span class="s1">&#39;vals&#39;</span><span class="p">]</span>

        <span class="c1"># Specify time of last set operation, used when comparing to delay to</span>
        <span class="c1"># check if additional waiting time is needed before next set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_last_set</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="c1"># should we call validate when getting data. default to False</span>
        <span class="c1"># intended to be changed in a subclass if you want the subclass</span>
        <span class="c1"># to perform a validation on get</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_on_get</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``get_raw`` is called to perform the actual data acquisition from the</span>
<span class="sd">        instrument. This method should either be overwritten to perform the</span>
<span class="sd">        desired operation or alternatively for :class:`.Parameter` a</span>
<span class="sd">        suitable method is automatically generated if ``get_cmd`` is supplied</span>
<span class="sd">        to the parameter constructor.</span>
<span class="sd">        The method is automatically wrapped to</span>
<span class="sd">        provide a ``get`` method on the parameter instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">set_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``set_raw`` is called to perform the actual setting of a parameter on</span>
<span class="sd">        the instrument. This method should either be overwritten to perform the</span>
<span class="sd">        desired operation or alternatively for :class:`.Parameter` a</span>
<span class="sd">        suitable method is automatically generated if ``set_cmd`` is supplied</span>
<span class="sd">        to the parameter constructor.</span>
<span class="sd">        The method is automatically wrapped to</span>
<span class="sd">        provide a ``set`` method on the parameter instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Include the instrument name with the Parameter name if possible.&quot;&quot;&quot;</span>
        <span class="n">inst_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inst_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inst_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">named_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no get cmd found in&#39;</span> <span class="o">+</span>
                                          <span class="s1">&#39; Parameter </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no set cmd found in&#39;</span> <span class="o">+</span>
                                          <span class="s1">&#39; Parameter </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">snapshot_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                      <span class="n">params_to_skip_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        State of the parameter as a JSON-compatible dict (everything that</span>
<span class="sd">        the custom JSON encoder class :class:&#39;qcodes.utils.helpers.NumpyJSONEncoder&#39;</span>
<span class="sd">        supports).</span>

<span class="sd">        Args:</span>
<span class="sd">            update (bool): If True, update the state by calling</span>
<span class="sd">                parameter.get().</span>
<span class="sd">                If False, just use the latest values in memory.</span>
<span class="sd">            params_to_skip_update: No effect but may be passed from super Class:</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: base snapshot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_exclude</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;Parameter (</span><span class="si">{self.name}</span><span class="s2">) is used in the snapshot while it &quot;</span>
                <span class="n">f</span><span class="s2">&quot;should be excluded from the snapshot&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_get</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_value</span> <span class="ow">and</span> <span class="n">update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="n">state</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest</span><span class="p">)</span> <span class="c1"># type: Dict[str, Any]</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;__class__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_class</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;full_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot_value</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;raw_value&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">],</span> <span class="n">datetime</span><span class="p">):</span>
            <span class="n">dttime</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">]</span> <span class="c1"># type: datetime</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dttime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;instrument&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="p">:</span>
                <span class="n">state</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                    <span class="s1">&#39;instrument&#39;</span><span class="p">:</span> <span class="n">full_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="p">),</span>
                    <span class="s1">&#39;instrument_name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="o">.</span><span class="n">name</span>
                <span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">attr_strip</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>  <span class="c1"># strip leading underscores</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Validator</span><span class="p">):</span>
                        <span class="n">state</span><span class="p">[</span><span class="n">attr_strip</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">state</span><span class="p">[</span><span class="n">attr_strip</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">_save_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">,</span> <span class="n">validate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update latest</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">validate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_parser</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_parser</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">val_mapping</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_latest</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="s1">&#39;ts&#39;</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span>
                        <span class="s1">&#39;raw_value&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_value</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_wrap_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ParamDataType</span><span class="p">])</span> <span class="o">-&gt;</span>\
            <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ParamDataType</span><span class="p">]:</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">get_function</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">get_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamDataType</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># There might be cases where a .get also has args/kwargs</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">get_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw_value</span> <span class="o">=</span> <span class="n">value</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parser</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># apply offset first (native scale)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># offset values</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                        <span class="c1"># offset contains multiple elements, one for each value</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">offset</span>
                                      <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                        <span class="c1"># Use single offset for all values</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>

                <span class="c1"># scale second</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Scale values</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                        <span class="c1"># Scale contains multiple elements, one for each value</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="n">scale</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">scale</span>
                                      <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                        <span class="c1"># Use single scale for all values</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_val_mapping</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; not in val_mapping&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_save_val</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_validate_on_get</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;getting </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">get_wrapper</span>

    <span class="k">def</span> <span class="nf">_wrap_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> \
            <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">set_function</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">set_wrapper</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># In some cases intermediate sweep values must be used.</span>
                <span class="c1"># Unless `self.step` is defined, get_sweep_values will return</span>
                <span class="c1"># a list containing only `value`.</span>
                <span class="n">steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ramp_values</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">step_index</span><span class="p">,</span> <span class="n">val_step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
                    <span class="c1"># even if the final value is valid we may be generating</span>
                    <span class="c1"># steps that are not so validate them too</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">val_step</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_mapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Convert set values using val_mapping dictionary</span>
                        <span class="n">raw_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_mapping</span><span class="p">[</span><span class="n">val_step</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">raw_value</span> <span class="o">=</span> <span class="n">val_step</span>

                    <span class="c1"># transverse transformation in reverse order as compared to</span>
                    <span class="c1"># getter:</span>
                    <span class="c1"># apply scale first</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                            <span class="c1"># Scale contains multiple elements, one for each value</span>
                            <span class="n">raw_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">*</span> <span class="n">scale</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">scale</span>
                                              <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">raw_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Use single scale for all values</span>
                            <span class="n">raw_value</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

                    <span class="c1"># apply offset next</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                            <span class="c1"># offset contains multiple elements, one for each value</span>
                            <span class="n">raw_value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">offset</span>
                                              <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">raw_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Use single offset for all values</span>
                            <span class="n">raw_value</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>

                    <span class="c1"># parser last</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_parser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">raw_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_parser</span><span class="p">(</span><span class="n">raw_value</span><span class="p">)</span>

                    <span class="c1"># Check if delay between set operations is required</span>
                    <span class="n">t_elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_last_set</span>
                    <span class="k">if</span> <span class="n">t_elapsed</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span><span class="p">:</span>
                        <span class="c1"># Sleep until time since last set is larger than</span>
                        <span class="c1"># self.inter_delay</span>
                        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span> <span class="o">-</span> <span class="n">t_elapsed</span><span class="p">)</span>

                    <span class="c1"># Start timer to measure execution time of set_function</span>
                    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

                    <span class="n">set_function</span><span class="p">(</span><span class="n">raw_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">raw_value</span> <span class="o">=</span> <span class="n">raw_value</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_save_val</span><span class="p">(</span><span class="n">val_step</span><span class="p">,</span>
                                   <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># Update last set time (used for calculating delays)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_t_last_set</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

                    <span class="c1"># Check if any delay after setting is required</span>
                    <span class="n">t_elapsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_last_set</span> <span class="o">-</span> <span class="n">t0</span>
                    <span class="k">if</span> <span class="n">t_elapsed</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_delay</span><span class="p">:</span>
                        <span class="c1"># Sleep until total time is larger than self.post_delay</span>
                        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">post_delay</span> <span class="o">-</span> <span class="n">t_elapsed</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;setting </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">),)</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">set_wrapper</span>

    <span class="k">def</span> <span class="nf">get_ramp_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Sized</span><span class="p">],</span>
                        <span class="n">step</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span>
                                                           <span class="nb">int</span><span class="p">,</span>
                                                           <span class="n">Sized</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return values to sweep from current value to target value.</span>
<span class="sd">        This method can be overridden to have a custom sweep behaviour.</span>
<span class="sd">        It can even be overridden by a generator.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: target value</span>
<span class="sd">            step: maximum step size</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of stepped values, including target value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sized</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to step a parameter&quot;</span>
                                   <span class="s2">&quot; with more than one value&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_latest</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">start_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_latest</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))):</span>
                <span class="c1"># something weird... parameter is numeric but one of the ends</span>
                <span class="c1"># isn&#39;t, even though it&#39;s valid.</span>
                <span class="c1"># probably MultiType with a mix of numeric and non-numeric types</span>
                <span class="c1"># just set the endpoint and move on</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s1">&#39;cannot sweep </span><span class="si">%s</span><span class="s1"> from </span><span class="si">%r</span><span class="s1"> to </span><span class="si">%r</span><span class="s1"> - jumping.&#39;</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">start_value</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="c1"># drop the initial value, we&#39;re already there</span>
            <span class="k">return</span> <span class="n">permissive_range</span><span class="p">(</span><span class="n">start_value</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">step</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate the value supplied.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: value to validate</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If the value is of the wrong type.</span>
<span class="sd">            ValueError: If the value is outside the bounds specified by the</span>
<span class="sd">               validator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="ow">or</span>
                       <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;Parameter: &#39;</span> <span class="o">+</span> <span class="n">context</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stepsize that this Parameter uses during set operation.</span>
<span class="sd">        Stepsize must be a positive number or None.</span>
<span class="sd">        If step is a positive number, this is the maximum value change</span>
<span class="sd">        allowed in one hardware call, so a single set can result in many</span>
<span class="sd">        calls to the hardware if the starting value is far from the target.</span>
<span class="sd">        If step is None stepping will not be used.</span>

<span class="sd">        :getter: Returns the current stepsize.</span>
<span class="sd">        :setter: Sets the value of the step.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: if step is set to not numeric or None</span>
<span class="sd">            ValueError: if step is set to negative</span>
<span class="sd">            TypeError:  if step is set to not integer or None for an integer parameter</span>
<span class="sd">            TypeError: if step is set to not a number on None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span>

    <span class="nd">@step</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure whether this Parameter uses steps during set operations.</span>
<span class="sd">        If step is a positive number, this is the maximum value change</span>
<span class="sd">        allowed in one hardware call, so a single set can result in many</span>
<span class="sd">        calls to the hardware if the starting value is far from the target.</span>
<span class="sd">        If step is None stepping will not be used.</span>

<span class="sd">        Args:</span>
<span class="sd">            step: A positive number or None, the largest change</span>
<span class="sd">                allowed in one call. All but the final change will attempt to</span>
<span class="sd">                change by +/- step exactly</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: if step is not numeric or None</span>
<span class="sd">            ValueError: if step is negative</span>
<span class="sd">            TypeError:  if step is not integer or None for an integer parameter</span>
<span class="sd">            TypeError: if step is not a number on None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="s1">&#39;is_numeric&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;you can only step numeric parameters&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;step must be a number&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_step</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">step</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;step must be positive&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">Ints</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;step must be a positive int for an Ints parameter&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_step</span> <span class="o">=</span> <span class="n">step</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">post_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Delay time after *start* of set operation, for each set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_delay</span>

    <span class="nd">@post_delay</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">post_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post_delay</span><span class="p">:</span> <span class="n">Number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure this parameter with a delay after the *start* of every set</span>
<span class="sd">        operation.</span>

<span class="sd">        Typically used in conjunction with `step` to create an effective</span>
<span class="sd">        ramp rate, but can also be used without a `step` to enforce a delay</span>
<span class="sd">        *after* every set. One might think of post_delay as how long a set</span>
<span class="sd">        operation is supposed to take. For example, there might be an</span>
<span class="sd">        instrument that needs extra time after setting a parameter although</span>
<span class="sd">        the command for setting the parameter returns quickly.</span>

<span class="sd">        Args:</span>
<span class="sd">            post_delay(Union[int, float]): the target time after the *start*</span>
<span class="sd">                of a set operation. The actual time will not be shorter than</span>
<span class="sd">                this, but may be longer if the underlying set call takes longer.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If delay is not int nor float</span>
<span class="sd">            ValueError: If delay is negative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">post_delay</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;post_delay (</span><span class="si">{}</span><span class="s1">) must be a number&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">post_delay</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">post_delay</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;post_delay (</span><span class="si">{}</span><span class="s1">) must not be negative&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">post_delay</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_delay</span> <span class="o">=</span> <span class="n">post_delay</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inter_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Delay time between consecutive set operations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inter_delay</span>

    <span class="nd">@inter_delay</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inter_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inter_delay</span><span class="p">:</span> <span class="n">Number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure this parameter with a delay between set operations.</span>

<span class="sd">        Typically used in conjunction with `step` to create an effective</span>
<span class="sd">        ramp rate, but can also be used without a `step` to enforce a delay</span>
<span class="sd">        *between* sets.</span>

<span class="sd">        Args:</span>
<span class="sd">            inter_delay(Union[int, float]): the minimum time between set calls.</span>
<span class="sd">                The actual time will not be shorter than this, but may be longer</span>
<span class="sd">                if the underlying set call takes longer.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If delay is not int nor float</span>
<span class="sd">            ValueError: If delay is negative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inter_delay</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;inter_delay (</span><span class="si">{}</span><span class="s1">) must be a number&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inter_delay</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">inter_delay</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;inter_delay (</span><span class="si">{}</span><span class="s1">) must not be negative&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inter_delay</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inter_delay</span> <span class="o">=</span> <span class="n">inter_delay</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Name of the parameter including the name of the instrument and</span>
<span class="sd">        submodule that the parameter may be bound to. The names are separated</span>
<span class="sd">        by underscores, like this: ``instrument_submodule_parameter``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_parts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_validator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (Deprecated) Set a validator `vals` for this parameter.</span>

<span class="sd">        Deprecated - reassign the `vals` attribute directly instead.</span>

<span class="sd">        Args:</span>
<span class="sd">            vals (Validator):  validator to set</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;set_validator is deprected use `inst.vals = MyValidator` instead&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">Validator</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;vals must be a Validator&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">instrument</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;InstrumentBase&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first instrument that this parameter is bound to.</span>
<span class="sd">        E.g if this is bound to a channel it will return the channel</span>
<span class="sd">        and not the instrument that the channel is bound too. Use</span>
<span class="sd">        :meth:`root_instrument` to get the real instrument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">root_instrument</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;InstrumentBase&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the fundamental instrument that this parameter belongs too.</span>
<span class="sd">        E.g if the parameter is bound to a channel this will return the</span>
<span class="sd">        fundamental instrument that that channel belongs to. Use</span>
<span class="sd">        :meth:`instrument` to get the channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="o">.</span><span class="n">root_instrument</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">set_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use a context manager to temporarily set the value of a parameter to</span>
<span class="sd">        a value. Example:</span>

<span class="sd">        &gt;&gt;&gt; from qcodes import Parameter</span>
<span class="sd">        &gt;&gt;&gt; p = Parameter(&quot;p&quot;, set_cmd=None, get_cmd=None)</span>
<span class="sd">        &gt;&gt;&gt; with p.set_to(3):</span>
<span class="sd">        ...    print(f&quot;p value in with block {p.get()}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;p value outside with block {p.get()}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">context_manager</span> <span class="o">=</span> <span class="n">_SetParamContext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">context_manager</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of the parts that make up the full name of this parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_parts</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;name_parts&#39;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="n">name_parts</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="c1"># add fallback for the case where someone has bound</span>
                <span class="c1"># the parameter to something that is not an instrument</span>
                <span class="c1"># but perhaps it has a name anyway?</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">name_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_parts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">name_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">short_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name_parts</span>


<div class="viewcode-block" id="Parameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.Parameter">[docs]</a><span class="k">class</span> <span class="nc">Parameter</span><span class="p">(</span><span class="n">_BaseParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parameter that represents a single degree of freedom.</span>
<span class="sd">    This is the standard parameter for Instruments, though it can also be</span>
<span class="sd">    used as a variable, i.e. storing/retrieving a value, or be subclassed for</span>
<span class="sd">    more complex uses.</span>

<span class="sd">    By default only gettable, returning its last value.</span>
<span class="sd">    This behaviour can be modified in two ways:</span>

<span class="sd">    1. Providing a ``get_cmd``/``set_cmd``, which can of the following:</span>

<span class="sd">       a. callable, with zero args for get_cmd, one arg for set_cmd</span>
<span class="sd">       b. VISA command string</span>
<span class="sd">       c. None, in which case it retrieves its last value for ``get_cmd``,</span>
<span class="sd">          and stores a value for ``set_cmd``</span>
<span class="sd">       d. False, in which case trying to get/set will raise an error.</span>

<span class="sd">    2. Creating a subclass with an explicit :meth:`get_raw`/:meth:`set_raw` method.</span>

<span class="sd">       This enables more advanced functionality. The :meth:`get_raw` and</span>
<span class="sd">       :meth:`set_raw` methods are automatically wrapped to provide ``get`` and</span>
<span class="sd">       ``set``.</span>

<span class="sd">    Parameters have a ``.get_latest`` method that simply returns the most</span>
<span class="sd">    recent set or measured value. This can be called ( ``param.get_latest()`` )</span>
<span class="sd">    or used in a ``Loop`` as if it were a (gettable-only) parameter itself:</span>

<span class="sd">        ``Loop(...).each(param.get_latest)``</span>


<span class="sd">    Args:</span>
<span class="sd">        name (str): the local name of the parameter. Should be a valid</span>
<span class="sd">            identifier, ie no spaces or special characters. If this parameter</span>
<span class="sd">            is part of an Instrument or Station, this is how it will be</span>
<span class="sd">            referenced from that parent, ie ``instrument.name`` or</span>
<span class="sd">            ``instrument.parameters[name]``</span>

<span class="sd">        instrument (Optional[Instrument]): the instrument this parameter</span>
<span class="sd">            belongs to, if any</span>

<span class="sd">        label (Optional[str]): Normally used as the axis label when this</span>
<span class="sd">            parameter is graphed, along with ``unit``.</span>

<span class="sd">        unit (Optional[str]): The unit of measure. Use ``&#39;&#39;`` for unitless.</span>

<span class="sd">        snapshot_get (Optional[bool]): False prevents any update to the</span>
<span class="sd">            parameter during a snapshot, even if the snapshot was called with</span>
<span class="sd">            ``update=True``, for example if it takes too long to update.</span>
<span class="sd">            Default True.</span>

<span class="sd">        snapshot_value (Optional[bool]): False prevents parameter value to be</span>
<span class="sd">            stored in the snapshot. Useful if the value is large.</span>

<span class="sd">        snapshot_exclude (Optional[bool]): True prevents parameter to be</span>
<span class="sd">            included in the snapshot. Useful if there are many of the same</span>
<span class="sd">            parameter which are clogging up the snapshot.</span>
<span class="sd">            Default False</span>

<span class="sd">        step (Optional[Union[int, float]]): max increment of parameter value.</span>
<span class="sd">            Larger changes are broken into multiple steps this size.</span>
<span class="sd">            When combined with delays, this acts as a ramp.</span>

<span class="sd">        scale (Optional[float]): Scale to multiply value with before</span>
<span class="sd">            performing set. the internally multiplied value is stored in</span>
<span class="sd">            `raw_value`. Can account for a voltage divider.</span>

<span class="sd">        inter_delay (Optional[Union[int, float]]): Minimum time (in seconds)</span>
<span class="sd">            between successive sets. If the previous set was less than this,</span>
<span class="sd">            it will wait until the condition is met.</span>
<span class="sd">            Can be set to 0 to go maximum speed with no errors.</span>

<span class="sd">        post_delay (Optional[Union[int, float]]): time (in seconds) to wait</span>
<span class="sd">            after the *start* of each set, whether part of a sweep or not.</span>
<span class="sd">            Can be set to 0 to go maximum speed with no errors.</span>

<span class="sd">        val_mapping (Optional[dict]): a bidirectional map data/readable values</span>
<span class="sd">            to instrument codes, expressed as a dict:</span>
<span class="sd">            ``{data_val: instrument_code}``</span>
<span class="sd">            For example, if the instrument uses &#39;0&#39; to mean 1V and &#39;1&#39; to mean</span>
<span class="sd">            10V, set val_mapping={1: &#39;0&#39;, 10: &#39;1&#39;} and on the user side you</span>
<span class="sd">            only see 1 and 10, never the coded &#39;0&#39; and &#39;1&#39;</span>
<span class="sd">            If vals is omitted, will also construct a matching Enum validator.</span>
<span class="sd">            NOTE: only applies to get if get_cmd is a string, and to set if</span>
<span class="sd">            set_cmd is a string.</span>
<span class="sd">            You can use ``val_mapping`` with ``get_parser``, in which case</span>
<span class="sd">            ``get_parser`` acts on the return value from the instrument first,</span>
<span class="sd">            then ``val_mapping`` is applied (in reverse).</span>

<span class="sd">        get_parser (Optional[Callable]): function to transform the response</span>
<span class="sd">            from get to the final output value. See also val_mapping</span>

<span class="sd">        set_parser (Optional[Callable]): function to transform the input set</span>
<span class="sd">            value to an encoded value sent to the instrument.</span>
<span class="sd">            See also val_mapping.</span>

<span class="sd">        vals (Optional[Validator]): Allowed values for setting this parameter.</span>
<span class="sd">            Only relevant if settable. Defaults to ``Numbers()``</span>

<span class="sd">        max_val_age (Optional[float]): The max time (in seconds) to trust a</span>
<span class="sd">            saved value obtained from get_latest(). If this parameter has not</span>
<span class="sd">            been set or measured more recently than this, perform an</span>
<span class="sd">            additional measurement.</span>

<span class="sd">        docstring (Optional[str]): documentation string for the __doc__</span>
<span class="sd">            field of the object. The __doc__ field of the instance is used by</span>
<span class="sd">            some help systems, but not all</span>

<span class="sd">        metadata (Optional[dict]): extra information to include with the</span>
<span class="sd">            JSON snapshot of the parameter</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">instrument</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Instrument&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">get_cmd</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">set_cmd</span><span class="p">:</span>  <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">initial_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_val_age</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">vals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Validator</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">docstring</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">instrument</span><span class="o">=</span><span class="n">instrument</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Enable set/get methods from get_cmd/set_cmd if given and</span>
        <span class="c1"># no `get`/`set` or `get_raw`/`set_raw` methods have been defined</span>
        <span class="c1"># in the scope of this class.</span>
        <span class="c1"># (previous call to `super().__init__` wraps existing get_raw/set_raw to</span>
        <span class="c1"># get/set methods)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">get_cmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">get_cmd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">max_val_age</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;Must have get method or specify get_cmd &#39;</span>
                                      <span class="s1">&#39;when max_val_age is set&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_raw</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest</span><span class="p">[</span><span class="s1">&#39;raw_value&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exec_str_ask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="s2">&quot;ask&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">instrument</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_raw</span> <span class="o">=</span> <span class="n">Command</span><span class="p">(</span><span class="n">arg_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cmd</span><span class="o">=</span><span class="n">get_cmd</span><span class="p">,</span> <span class="n">exec_str</span><span class="o">=</span><span class="n">exec_str_ask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_raw</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">set_cmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">set_cmd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_raw</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_save_val</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exec_str_write</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instrument</span><span class="p">,</span> <span class="s2">&quot;write&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">instrument</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_raw</span> <span class="o">=</span> <span class="n">Command</span><span class="p">(</span><span class="n">arg_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmd</span><span class="o">=</span><span class="n">set_cmd</span><span class="p">,</span>
                                       <span class="n">exec_str</span><span class="o">=</span><span class="n">exec_str_write</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_raw</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="s1">&#39;vals&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span> <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

        <span class="k">if</span> <span class="n">initial_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">initial_value</span><span class="p">)</span>

        <span class="c1"># generate default docstring</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
            <span class="s1">&#39;Parameter class:&#39;</span><span class="p">,</span>
            <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;* `name` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;* `label` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
            <span class="s1">&#39;* `unit` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
            <span class="s1">&#39;* `vals` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">docstring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
                <span class="n">docstring</span><span class="p">,</span>
                <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">))</span>

<div class="viewcode-block" id="Parameter.__getitem__"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.Parameter.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slice a Parameter to get a SweepValues object</span>
<span class="sd">        to iterate over during a sweep</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SweepFixedValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parameter.increment"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.Parameter.increment">[docs]</a>    <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Increment the parameter with a value</span>

<span class="sd">        Args:</span>
<span class="sd">            value (float): value to be added to the parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parameter.sweep"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.Parameter.sweep">[docs]</a>    <span class="k">def</span> <span class="nf">sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a collection of parameter values to be iterated over.</span>
<span class="sd">        Requires `start` and `stop` and (`step` or `num`)</span>
<span class="sd">        The sign of `step` is not relevant.</span>

<span class="sd">        Args:</span>
<span class="sd">            start (Union[int, float]): The starting value of the sequence.</span>
<span class="sd">            stop (Union[int, float]): The end value of the sequence.</span>
<span class="sd">            step (Optional[Union[int, float]]):  Spacing between values.</span>
<span class="sd">            num (Optional[int]): Number of values to generate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SweepFixedValues: collection of parameter values to be</span>
<span class="sd">            iterated over</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; sweep(0, 10, num=5)</span>
<span class="sd">             [0.0, 2.5, 5.0, 7.5, 10.0]</span>
<span class="sd">            &gt;&gt;&gt; sweep(5, 10, step=1)</span>
<span class="sd">            [5.0, 6.0, 7.0, 8.0, 9.0, 10.0]</span>
<span class="sd">            &gt;&gt;&gt; sweep(15, 10.5, step=1.5)</span>
<span class="sd">            &gt;[15.0, 13.5, 12.0, 10.5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SweepFixedValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
                                <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ParameterWithSetpoints"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.ParameterWithSetpoints">[docs]</a><span class="k">class</span> <span class="nc">ParameterWithSetpoints</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parameter that has associated setpoints. The setpoints is nothing</span>
<span class="sd">    more than a list of other parameters that describe the values, names</span>
<span class="sd">    and units of the setpoint axis for this parameter.</span>

<span class="sd">    In most cases this will probably be a parameter that returns an array.</span>
<span class="sd">    It is expected that the setpoint arrays are 1D arrays such that the</span>
<span class="sd">    combined shape of the parameter e.g. if parameter is of shape (m,n)</span>
<span class="sd">    `setpoints` is a list of parameters of shape (m,) and (n,)</span>

<span class="sd">    In all other ways this is identical to  :class:`Parameter` See the</span>
<span class="sd">    documentation of :class:`Parameter` for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">vals</span><span class="p">:</span> <span class="n">Validator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">setpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">_BaseParameter</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">snapshot_get</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">snapshot_value</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">Arrays</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;A ParameterWithSetpoints must have an Arrays &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;validator got {type(vals)}&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">shape_unevaluated</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;A ParameterWithSetpoints must have a shape &quot;</span>
                               <span class="s2">&quot;defined for its validator.&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span> <span class="n">snapshot_get</span><span class="o">=</span><span class="n">snapshot_get</span><span class="p">,</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="n">snapshot_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">setpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_BaseParameter</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span> <span class="o">=</span> <span class="n">setpoints</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_on_get</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">setpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_BaseParameter</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sequence of parameters to use as setpoints for this parameter.</span>

<span class="sd">        :getter: Returns a list of parameters currently used for setpoints.</span>
<span class="sd">        :setter: Sets the parameters to be used as setpoints from a sequence.</span>
<span class="sd">            The combined shape of the parameters supplied must be consistent</span>
<span class="sd">            with the data shape of the data returned from get on the parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setpoints</span>

    <span class="nd">@setpoints</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">setpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setpoints</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_BaseParameter</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">setpointarray</span> <span class="ow">in</span> <span class="n">setpoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setpointarray</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Setpoints is of type {type(setpointarray)}&quot;</span>
                                <span class="n">f</span><span class="s2">&quot; expcected a QCoDeS parameter&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setpoints</span> <span class="o">=</span> <span class="n">setpoints</span>

<div class="viewcode-block" id="ParameterWithSetpoints.validate_consistent_shape"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.ParameterWithSetpoints.validate_consistent_shape">[docs]</a>    <span class="k">def</span> <span class="nf">validate_consistent_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verifies that the shape of the Array Validator of the parameter</span>
<span class="sd">        is consistent with the Validator of the Setpoints. This requires that</span>
<span class="sd">        both the setpoints and the actual parameters have validators</span>
<span class="sd">        of type Arrays with a defined shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">Arrays</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Can only validate shapes for parameters &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;with Arrays validator. </span><span class="si">{self.name}</span><span class="s2"> does &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;not have an Arrays validator.&quot;</span><span class="p">)</span>
        <span class="n">output_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">shape_unevaluated</span>
        <span class="n">setpoints_shape_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">Arrays</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Can only validate shapes for parameters &quot;</span>
                                 <span class="n">f</span><span class="s2">&quot;with Arrays validator. </span><span class="si">{sp.name}</span><span class="s2"> is &quot;</span>
                                 <span class="n">f</span><span class="s2">&quot;a setpoint vector but does not have an &quot;</span>
                                 <span class="n">f</span><span class="s2">&quot;Arrays validator&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">shape_unevaluated</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">setpoints_shape_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">shape_unevaluated</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">setpoints_shape_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">shape_unevaluated</span><span class="p">)</span>
        <span class="n">setpoints_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">setpoints_shape_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Trying to validate shape but parameter &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.name}</span><span class="s2"> does not define a shape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">output_shape</span> <span class="ow">or</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">setpoints_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;One or more dimensions have unknown shape &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;when comparing output: </span><span class="si">{output_shape}</span><span class="s2"> to &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;setpoints: </span><span class="si">{setpoints_shape}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output_shape</span> <span class="o">!=</span> <span class="n">setpoints_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Shape of output is not consistent with &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;setpoints. Output is shape </span><span class="si">{output_shape}</span><span class="s2"> and &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;setpoints are shape </span><span class="si">{setpoints_shape}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;For parameter </span><span class="si">{self.full_name}</span><span class="s2"> verified &quot;</span>
                 <span class="n">f</span><span class="s2">&quot;that </span><span class="si">{output_shape}</span><span class="s2"> matches </span><span class="si">{setpoints_shape}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParameterWithSetpoints.validate"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.ParameterWithSetpoints.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParamDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overwrites the standard ``validate`` method to also check the the</span>
<span class="sd">        parameter has consistent shape with its setpoints. This only makes</span>
<span class="sd">        sense if the parameter has an Arrays</span>
<span class="sd">        validator</span>

<span class="sd">        Arguments are passed to the super method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">Arrays</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validate_consistent_shape</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DelegateParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.DelegateParameter">[docs]</a><span class="k">class</span> <span class="nc">DelegateParameter</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The `DelegateParameter` wraps a given `source`-parameter. Setting/getting</span>
<span class="sd">    it results in a set/get of the source parameter with the provided</span>
<span class="sd">    arguments.</span>

<span class="sd">    The reason for using a `DelegateParameter` instead of the source parameter</span>
<span class="sd">    is to provide all the functionality of the Parameter base class without</span>
<span class="sd">    overwriting properties of the source: for example to set a different</span>
<span class="sd">    Scaling factor and unit on the `DelegateParameter` without changing those</span>
<span class="sd">    in the source parameter</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>

        <span class="k">for</span> <span class="n">ka</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;snapshot_value&#39;</span><span class="p">),</span>
                             <span class="p">(</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;_snapshot_value&#39;</span><span class="p">)):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">ka</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ka</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">param</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;set_cmd&#39;</span><span class="p">,</span> <span class="s1">&#39;get_cmd&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;It is not allowed to set &quot;</span><span class="si">{cmd}</span><span class="s1">&quot; of a &#39;</span>
                               <span class="n">f</span><span class="s1">&#39;DelegateParameter because the one of the &#39;</span>
                               <span class="n">f</span><span class="s1">&#39;source parameter is supposed to be used.&#39;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Disable the warnings until MultiParameter has been</span>
    <span class="c1"># replaced and name/label/unit can live in _BaseParameter</span>
    <span class="c1"># pylint: disable=method-hidden</span>
<div class="viewcode-block" id="DelegateParameter.get_raw"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.DelegateParameter.get_raw">[docs]</a>    <span class="k">def</span> <span class="nf">get_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">get</span><span class="p">()</span></div>

    <span class="c1"># same as for `get_raw`</span>
    <span class="c1"># pylint: disable=method-hidden</span>
<div class="viewcode-block" id="DelegateParameter.set_raw"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.DelegateParameter.set_raw">[docs]</a>    <span class="k">def</span> <span class="nf">set_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="DelegateParameter.snapshot_base"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.DelegateParameter.snapshot_base">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                      <span class="n">params_to_skip_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="n">snapshot</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">snapshot_base</span><span class="p">(</span>
            <span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">,</span>
            <span class="n">params_to_skip_update</span><span class="o">=</span><span class="n">params_to_skip_update</span>
        <span class="p">)</span>
        <span class="n">snapshot</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="s1">&#39;source_parameter&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">snapshot</span><span class="p">(</span><span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">)}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">snapshot</span></div></div>


<div class="viewcode-block" id="ArrayParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.ArrayParameter">[docs]</a><span class="k">class</span> <span class="nc">ArrayParameter</span><span class="p">(</span><span class="n">_BaseParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A gettable parameter that returns an array of values.</span>
<span class="sd">    Not necessarily part of an instrument.</span>

<span class="sd">    For new driver we strongly recommend using</span>
<span class="sd">    :class:`.ParameterWithSetpoints` which is both more flexible and</span>
<span class="sd">    significantly easier to use</span>

<span class="sd">    Subclasses should define a ``.get_raw`` method, which returns an array.</span>
<span class="sd">    This method is automatically wrapped to provide a ``.get`` method.</span>

<span class="sd">    ArrayParameter can be used in both a</span>
<span class="sd">    :class:`qcodes.dataset.measurements.Measurement`</span>
<span class="sd">    as well as in the legacy :class:`qcodes.loops.Loop`</span>
<span class="sd">    and :class:`qcodes.measure.Measure` measurements</span>

<span class="sd">    When used in a ``Loop`` or ``Measure`` operation, this will be entered</span>
<span class="sd">    into a single ``DataArray``, with extra dimensions added by the ``Loop``.</span>
<span class="sd">    The constructor args describe the array we expect from each ``.get`` call</span>
<span class="sd">    and how it should be handled.</span>

<span class="sd">    For now you must specify upfront the array shape, and this cannot change</span>
<span class="sd">    from one call to the next. Later we intend to require only that you specify</span>
<span class="sd">    the dimension, and the size of each dimension can vary from call to call.</span>

<span class="sd">    Args:</span>
<span class="sd">        name (str): the local name of the parameter. Should be a valid</span>
<span class="sd">            identifier, ie no spaces or special characters. If this parameter</span>
<span class="sd">            is part of an Instrument or Station, this is how it will be</span>
<span class="sd">            referenced from that parent, ie ``instrument.name`` or</span>
<span class="sd">            ``instrument.parameters[name]``</span>

<span class="sd">        shape (Tuple[int]): The shape (as used in numpy arrays) of the array</span>
<span class="sd">            to expect. Scalars should be denoted by (), 1D arrays as (n,),</span>
<span class="sd">            2D arrays as (n, m), etc.</span>

<span class="sd">        instrument (Optional[Instrument]): the instrument this parameter</span>
<span class="sd">            belongs to, if any</span>

<span class="sd">        label (Optional[str]): Normally used as the axis label when this</span>
<span class="sd">            parameter is graphed, along with ``unit``.</span>

<span class="sd">        unit (Optional[str]): The unit of measure. Use ``&#39;&#39;`` for unitless.</span>

<span class="sd">        setpoints (Optional[Tuple[array]]):</span>
<span class="sd">            ``array`` can be a DataArray, numpy.ndarray, or sequence.</span>
<span class="sd">            The setpoints for each dimension of the returned array. An</span>
<span class="sd">            N-dimension item should have N setpoint arrays, where the first is</span>
<span class="sd">            1D, the second 2D, etc.</span>
<span class="sd">            If omitted for any or all items, defaults to integers from zero in</span>
<span class="sd">            each respective direction.</span>
<span class="sd">            Note: if the setpoints will be different each measurement, leave</span>
<span class="sd">            this out and return the setpoints (with extra names) in ``.get``.</span>

<span class="sd">        setpoint_names (Optional[Tuple[str]]): one identifier (like</span>
<span class="sd">            ``name``) per setpoint array. Ignored if a setpoint is a</span>
<span class="sd">            DataArray, which already has a name.</span>

<span class="sd">        setpoint_labels (Optional[Tuple[str]]): one label (like ``labels``)</span>
<span class="sd">            per setpoint array. Ignored if a setpoint is a DataArray, which</span>
<span class="sd">            already has a label.</span>

<span class="sd">        setpoint_units (Optional[Tuple[str]]): one label (like ``v``)</span>
<span class="sd">            per setpoint array. Ignored if a setpoint is a DataArray, which</span>
<span class="sd">            already has a unit.</span>

<span class="sd">        docstring (Optional[str]): documentation string for the __doc__</span>
<span class="sd">            field of the object. The __doc__ field of the instance is used by</span>
<span class="sd">            some help systems, but not all</span>

<span class="sd">        snapshot_get (bool): Prevent any update to the parameter, for example</span>
<span class="sd">            if it takes too long to update. Default True.</span>

<span class="sd">        snapshot_value: Should the value of the parameter be stored in the</span>
<span class="sd">            snapshot. Unlike Parameter this defaults to False as</span>
<span class="sd">            ArrayParameters are potentially huge.</span>

<span class="sd">        snapshot_exclude (Optional[bool]): True prevents parameter to be</span>
<span class="sd">            included in the snapshot. Useful if there are many of the same</span>
<span class="sd">            parameter which are clogging up the snapshot.</span>

<span class="sd">            Default False</span>

<span class="sd">        metadata (Optional[dict]): extra information to include with the</span>
<span class="sd">            JSON snapshot of the parameter</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                 <span class="n">instrument</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Instrument&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">setpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">setpoint_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">setpoint_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">setpoint_units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">docstring</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">snapshot_get</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">snapshot_value</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">snapshot_exclude</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">snapshot_get</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="n">snapshot_value</span><span class="p">,</span>
                         <span class="n">snapshot_exclude</span><span class="o">=</span><span class="n">snapshot_exclude</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">):</span>
            <span class="c1"># TODO (alexcjohnson): can we support, ala Combine?</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;ArrayParameters do not support set &#39;</span>
                                 <span class="s1">&#39;at this time.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;setpoint_names&#39;</span><span class="p">,</span> <span class="s1">&#39;setpoint_labels&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;setpoint_units&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span> <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

        <span class="n">nt</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shapes must be a tuple of ints, not &#39;</span> <span class="o">+</span>
                             <span class="nb">repr</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="c1"># require one setpoint per dimension of shape</span>
        <span class="n">sp_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),)</span>

        <span class="n">sp_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">,</span>
                    <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">setpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">setpoints</span><span class="p">,</span> <span class="n">sp_types</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">sp_shape</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setpoints must be a tuple of arrays&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">setpoint_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">setpoint_names</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="n">sp_shape</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setpoint_names must be a tuple of strings&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">setpoint_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">setpoint_labels</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>
                                   <span class="n">shape</span><span class="o">=</span><span class="n">sp_shape</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setpoint_labels must be a tuple of strings&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">setpoint_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">setpoint_units</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>
                                   <span class="n">shape</span><span class="o">=</span><span class="n">sp_shape</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setpoint_units must be a tuple of strings&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span> <span class="o">=</span> <span class="n">setpoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span> <span class="o">=</span> <span class="n">setpoint_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_labels</span> <span class="o">=</span> <span class="n">setpoint_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_units</span> <span class="o">=</span> <span class="n">setpoint_units</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
            <span class="s1">&#39;Parameter class:&#39;</span><span class="p">,</span>
            <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;* `name` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;* `label` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
            <span class="s1">&#39;* `unit` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
            <span class="s1">&#39;* `shape` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">docstring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
                <span class="n">docstring</span><span class="p">,</span>
                <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;ArrayParameter must have a get, set or both&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">setpoint_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Full names of setpoints including instrument names if available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># omit the last part of name_parts which is the parameter name</span>
        <span class="c1"># and not part of the setpoint names</span>
        <span class="n">inst_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">inst_name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">spnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">spname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">spnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inst_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">spname</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">spnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">spnames</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span></div>


<span class="k">def</span> <span class="nf">_is_nested_sequence_or_none</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">shapes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Validator for MultiParameter setpoints/names/labels&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),)):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">obji</span><span class="p">,</span> <span class="n">shapei</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">shapes</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">obji</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shapei</span><span class="p">),)):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="MultiParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.MultiParameter">[docs]</a><span class="k">class</span> <span class="nc">MultiParameter</span><span class="p">(</span><span class="n">_BaseParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A gettable parameter that returns multiple values with separate names,</span>
<span class="sd">    each of arbitrary shape.</span>
<span class="sd">    Not necessarily part of an instrument.</span>

<span class="sd">    Subclasses should define a ``.get_raw`` method, which returns a sequence of</span>
<span class="sd">    values. This method is automatically wrapped to provide a ``.get`` method.</span>
<span class="sd">    When used in a ``Loop`` or ``Measure`` operation, each of these</span>
<span class="sd">    values will be entered into a different ``DataArray``. The constructor</span>
<span class="sd">    args describe what data we expect from each ``.get`` call and how it</span>
<span class="sd">    should be handled. ``.get`` should always return the same number of items,</span>
<span class="sd">    and most of the constructor arguments should be tuples of that same length.</span>

<span class="sd">    For now you must specify upfront the array shape of each item returned by</span>
<span class="sd">    ``.get_raw``, and this cannot change from one call to the next. Later we</span>
<span class="sd">    intend to require only that you specify the dimension of each item returned,</span>
<span class="sd">    and the size of each dimension can vary from call to call.</span>

<span class="sd">    Args:</span>
<span class="sd">        name (str): the local name of the whole parameter. Should be a valid</span>
<span class="sd">            identifier, ie no spaces or special characters. If this parameter</span>
<span class="sd">            is part of an Instrument or Station, this is how it will be</span>
<span class="sd">            referenced from that parent, ie ``instrument.name`` or</span>
<span class="sd">            ``instrument.parameters[name]``</span>

<span class="sd">        names (Tuple[str]): A name for each item returned by a ``.get``</span>
<span class="sd">            call. Will be used as the basis of the ``DataArray`` names</span>
<span class="sd">            when this parameter is used to create a ``DataSet``.</span>

<span class="sd">        shapes (Tuple[Tuple[int]]): The shape (as used in numpy arrays) of</span>
<span class="sd">            each item. Scalars should be denoted by (), 1D arrays as (n,),</span>
<span class="sd">            2D arrays as (n, m), etc.</span>

<span class="sd">        instrument (Optional[Instrument]): the instrument this parameter</span>
<span class="sd">            belongs to, if any</span>

<span class="sd">        labels (Optional[Tuple[str]]): A label for each item. Normally used</span>
<span class="sd">            as the axis label when a component is graphed, along with the</span>
<span class="sd">            matching entry from ``units``.</span>

<span class="sd">        units (Optional[Tuple[str]]): The unit of measure for each item.</span>
<span class="sd">            Use ``&#39;&#39;`` or ``None`` for unitless values.</span>

<span class="sd">        setpoints (Optional[Tuple[Tuple[array]]]):</span>
<span class="sd">            ``array`` can be a DataArray, numpy.ndarray, or sequence.</span>
<span class="sd">            The setpoints for each returned array. An N-dimension item should</span>
<span class="sd">            have N setpoint arrays, where the first is 1D, the second 2D, etc.</span>
<span class="sd">            If omitted for any or all items, defaults to integers from zero in</span>
<span class="sd">            each respective direction.</span>
<span class="sd">            Note: if the setpoints will be different each measurement, leave</span>
<span class="sd">            this out and return the setpoints (with extra names) in ``.get``.</span>

<span class="sd">        setpoint_names (Optional[Tuple[Tuple[str]]]): one identifier (like</span>
<span class="sd">            ``name``) per setpoint array. Ignored if a setpoint is a</span>
<span class="sd">            DataArray, which already has a name.</span>

<span class="sd">        setpoint_labels (Optional[Tuple[Tuple[str]]]): one label (like</span>
<span class="sd">            ``labels``) per setpoint array. Ignored if a setpoint is a</span>
<span class="sd">            DataArray, which already has a label.</span>

<span class="sd">        setpoint_units (Optional[Tuple[Tuple[str]]]): one unit (like</span>
<span class="sd">            ``V``) per setpoint array. Ignored if a setpoint is a</span>
<span class="sd">            DataArray, which already has a unit.</span>

<span class="sd">        docstring (Optional[str]): documentation string for the __doc__</span>
<span class="sd">            field of the object. The __doc__ field of the instance is used by</span>
<span class="sd">            some help systems, but not all</span>

<span class="sd">        snapshot_get (bool): Prevent any update to the parameter, for example</span>
<span class="sd">            if it takes too long to update. Default True.</span>

<span class="sd">        snapshot_value: Should the value of the parameter be stored in the</span>
<span class="sd">            snapshot. Unlike Parameter this defaults to False as</span>
<span class="sd">            MultiParameters are potentially huge.</span>

<span class="sd">        snapshot_exclude (Optional[bool]): True prevents parameter to be</span>
<span class="sd">            included in the snapshot. Useful if there are many of the same</span>
<span class="sd">            parameter which are clogging up the snapshot.</span>
<span class="sd">            Default False</span>

<span class="sd">        metadata (Optional[dict]): extra information to include with the</span>
<span class="sd">            JSON snapshot of the parameter</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="n">shapes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
                 <span class="n">instrument</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Instrument&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">setpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">setpoint_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">setpoint_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">setpoint_units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">docstring</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">snapshot_get</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">snapshot_value</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">snapshot_exclude</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">snapshot_get</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="n">snapshot_value</span><span class="p">,</span>
                         <span class="n">snapshot_exclude</span><span class="o">=</span><span class="n">snapshot_exclude</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;setpoint_names&#39;</span><span class="p">,</span> <span class="s1">&#39;setpoint_labels&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;setpoint_units&#39;</span><span class="p">,</span> <span class="s1">&#39;names&#39;</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;names must be a tuple of strings, not &#39;</span> <span class="o">+</span>
                             <span class="nb">repr</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span> <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="n">nt</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_sequence_of</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shapes must be a tuple of tuples &#39;</span>
                             <span class="s1">&#39;of ints, not &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">shapes</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="o">=</span> <span class="n">shapes</span>

        <span class="n">sp_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">,</span>
                    <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_nested_sequence_or_none</span><span class="p">(</span><span class="n">setpoints</span><span class="p">,</span> <span class="n">sp_types</span><span class="p">,</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setpoints must be a tuple of tuples of arrays&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_nested_sequence_or_none</span><span class="p">(</span><span class="n">setpoint_names</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;setpoint_names must be a tuple of tuples of strings&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_nested_sequence_or_none</span><span class="p">(</span><span class="n">setpoint_labels</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;setpoint_labels must be a tuple of tuples of strings&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_nested_sequence_or_none</span><span class="p">(</span><span class="n">setpoint_units</span><span class="p">,</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;setpoint_units must be a tuple of tuples of strings&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span> <span class="o">=</span> <span class="n">setpoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span> <span class="o">=</span> <span class="n">setpoint_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_labels</span> <span class="o">=</span> <span class="n">setpoint_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_units</span> <span class="o">=</span> <span class="n">setpoint_units</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
            <span class="s1">&#39;MultiParameter class:&#39;</span><span class="p">,</span>
            <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;* `name` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;* `names` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">),</span>
            <span class="s1">&#39;* `labels` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">),</span>
            <span class="s1">&#39;* `units` </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">docstring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
                <span class="n">docstring</span><span class="p">,</span>
                <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;MultiParameter must have a get, set or both&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">short_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        short_names is identical to names i.e. the names of the parameter</span>
<span class="sd">        parts but does not add the instrument name.</span>

<span class="sd">        It exists for consistency with instruments and other parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Names of the parameter components including the name of the instrument</span>
<span class="sd">        and submodule that the parameter may be bound to. The name parts are</span>
<span class="sd">        separated by underscores, like this: ``instrument_submodule_parameter``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inst_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">inst_name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">inst_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">setpoint_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Full names of setpoints including instrument names if available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># omit the last part of name_parts which is the parameter name</span>
        <span class="c1"># and not part of the setpoint names</span>
        <span class="n">inst_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">inst_name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">full_sp_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sp_group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span><span class="p">:</span>
                <span class="n">full_sp_names_subgroupd</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">spname</span> <span class="ow">in</span> <span class="n">sp_group</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">spname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">full_sp_names_subgroupd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inst_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">spname</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">full_sp_names_subgroupd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">full_sp_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">full_sp_names_subgroupd</span><span class="p">))</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">full_sp_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoint_names</span></div>


<div class="viewcode-block" id="GetLatest"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.GetLatest">[docs]</a><span class="k">class</span> <span class="nc">GetLatest</span><span class="p">(</span><span class="n">DelegateAttributes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for a Parameter that just returns the last set or measured value</span>
<span class="sd">    stored in the Parameter itself.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Can be called:</span>
<span class="sd">        &gt;&gt;&gt; param.get_latest()</span>
<span class="sd">        &gt;&gt;&gt; # Or used as if it were a gettable-only parameter itself:</span>
<span class="sd">        &gt;&gt;&gt; Loop(...).each(param.get_latest)</span>

<span class="sd">    Args:</span>
<span class="sd">        parameter (Parameter): Parameter to be wrapped</span>

<span class="sd">        max_val_age (Optional[int]): The max time (in seconds) to trust a</span>
<span class="sd">            saved value obtained from get_latest(). If this parameter has not</span>
<span class="sd">            been set or measured more recently than this, perform an</span>
<span class="sd">            additional measurement.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">max_val_age</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span> <span class="o">=</span> <span class="n">parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_val_age</span> <span class="o">=</span> <span class="n">max_val_age</span>

    <span class="n">delegate_attr_objects</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;parameter&#39;</span><span class="p">]</span>
    <span class="n">omit_delegate_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;set&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="GetLatest.get"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.GetLatest.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return latest value if time since get was less than</span>
<span class="sd">        `self.max_val_age`, otherwise perform `get()` and return result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">_latest</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_val_age</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Return last value since max_val_age is not specified</span>
            <span class="k">return</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">oldest_ok_val</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_val_age</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">oldest_ok_val</span><span class="p">:</span>
                <span class="c1"># Time of last get exceeds max_val_age seconds, need to</span>
                <span class="c1"># perform new .get()</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GetLatest.get_timestamp"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.GetLatest.get_timestamp">[docs]</a>    <span class="k">def</span> <span class="nf">get_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the age of the latest parameter value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">_latest</span>
        <span class="k">return</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span></div>


<div class="viewcode-block" id="combine"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.combine">[docs]</a><span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="o">*</span><span class="n">parameters</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">aggregator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine parameters into one sweepable parameter</span>

<span class="sd">    Args:</span>
<span class="sd">        *parameters (qcodes.instrument.parameter.Parameter): the parameters to</span>
<span class="sd">            combine</span>
<span class="sd">        name (str): the name of the paramter</span>
<span class="sd">        label (Optional[str]): the label of the combined parameter</span>
<span class="sd">        unit (Optional[str]): the unit of the combined parameter</span>
<span class="sd">        aggregator (Optional[Callable[list[Any]]]): a function to aggregate</span>
<span class="sd">            the set values into one</span>

<span class="sd">    A combined parameter sets all the combined parameters at every point of the</span>
<span class="sd">    sweep.</span>
<span class="sd">    The sets are called in the same order the parameters are, and</span>
<span class="sd">    sequantially.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
    <span class="n">multi_par</span> <span class="o">=</span> <span class="n">CombinedParameter</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span>
                                  <span class="n">aggregator</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">multi_par</span></div>


<div class="viewcode-block" id="CombinedParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.CombinedParameter">[docs]</a><span class="k">class</span> <span class="nc">CombinedParameter</span><span class="p">(</span><span class="n">Metadatable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A combined parameter</span>

<span class="sd">    Args:</span>
<span class="sd">        *parameters (qcodes.instrument.parameter.Parameter): the parameters to</span>
<span class="sd">            combine.</span>
<span class="sd">        name (str): the name of the parameter</span>
<span class="sd">        label (Optional[str]): the label of the combined parameter</span>
<span class="sd">        unit (Optional[str]): the unit of the combined parameter</span>
<span class="sd">        aggregator (Optional[Callable[list[Any]]]): a function to aggregate</span>
<span class="sd">            the set values into one</span>

<span class="sd">    A combined parameter sets all the combined parameters at every point of the</span>
<span class="sd">    sweep.</span>
<span class="sd">    The sets are called in the same order the parameters are, and</span>
<span class="sd">    sequentially.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Parameter</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">units</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">aggregator</span><span class="p">:</span> <span class="n">Callable</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># TODO(giulioungaretti)temporary hack</span>
        <span class="c1"># starthack</span>
        <span class="c1"># this is a dummy parameter</span>
        <span class="c1"># that mimicks the api that a normal parameter has</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Parameter name must be a valid identifier &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;got </span><span class="si">{name}</span><span class="s2"> which is not. Parameter names &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;cannot start with a number and &quot;</span>
                             <span class="n">f</span><span class="s2">&quot;must not contain spaces or special characters&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>
        <span class="c1"># mypy will complain that a callable does not have these attributes</span>
        <span class="c1"># but you can still create them here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">full_name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># type: ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># type: ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>  <span class="c1"># type: ignore</span>

        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warn_units</span><span class="p">(</span><span class="s1">&#39;CombinedParameter&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>  <span class="c1"># type: ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># endhack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameter</span><span class="o">.</span><span class="n">set</span> <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sets</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">aggregator</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">aggregator</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;aggregate&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">)</span>

<div class="viewcode-block" id="CombinedParameter.set"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.CombinedParameter.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set multiple parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            index (int): the index of the setpoints one wants to set</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: values that where actually set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">setFunction</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sets</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">setFunction</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="CombinedParameter.sweep"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.CombinedParameter.sweep">[docs]</a>    <span class="k">def</span> <span class="nf">sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">array</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;CombinedParameter&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new combined parameter to be iterated over.</span>
<span class="sd">        One can sweep over either:</span>

<span class="sd">         - n array of lenght m</span>
<span class="sd">         - one nxm array</span>

<span class="sd">        where n is the number of combined parameters</span>
<span class="sd">        and m is the number of setpoints</span>

<span class="sd">        Args:</span>
<span class="sd">            *array(numpy.ndarray): array(s) of setopoints</span>

<span class="sd">        Returns:</span>
<span class="sd">            combined parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if it&#39;s a list of arrays, convert to one array</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">array</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Arrays have different number of setpoints&#39;</span><span class="p">)</span>
            <span class="n">nparray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># cast to array in case users</span>
            <span class="c1"># decide to not read docstring</span>
            <span class="c1"># and pass a 2d list</span>
            <span class="n">nparray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_error_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot; Dimensionality of array does not match</span><span class="se">\</span>
<span class="s2">                        the number of parameter combined. Expected a </span><span class="se">\</span>
<span class="s2">                        </span><span class="si">{}</span><span class="s2"> dimensional array, got a </span><span class="si">{}</span><span class="s2"> dimensional array. </span><span class="se">\</span>
<span class="s2">                        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nparray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_error_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">,</span>
                                                   <span class="n">nparray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># this means the array is 1d</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_error_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">new</span><span class="o">.</span><span class="n">setpoints</span> <span class="o">=</span> <span class="n">nparray</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new</span></div>

    <span class="k">def</span> <span class="nf">_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">vals</span><span class="p">):</span>
        <span class="c1"># check f args</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># dimension of the sweep_values</span>
        <span class="c1"># i.e. how many setpoint</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setpoints</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="CombinedParameter.snapshot_base"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.CombinedParameter.snapshot_base">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        State of the combined parameter as a JSON-compatible dict (everything that</span>
<span class="sd">        the custom JSON encoder class :class:&#39;qcodes.utils.helpers.NumpyJSONEncoder&#39;</span>
<span class="sd">        supports).</span>

<span class="sd">        Args:</span>
<span class="sd">            update (bool):</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: base snapshot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta_data</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;__class__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_class</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">unit</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">label</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;full_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">full_name</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;aggregator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="n">meta_data</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">param</span><span class="p">)]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">snapshot</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">meta_data</span></div></div>


<div class="viewcode-block" id="InstrumentRefParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.InstrumentRefParameter">[docs]</a><span class="k">class</span> <span class="nc">InstrumentRefParameter</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An InstrumentRefParameter</span>

<span class="sd">    Args:</span>
<span class="sd">        name (str): the name of the parameter that one wants to add.</span>

<span class="sd">        instrument (Optional[Instrument]): the &quot;parent&quot; instrument this</span>
<span class="sd">            parameter is attached to, if any.</span>

<span class="sd">        initial_value (Optional[str]): starting value, may be None even if</span>
<span class="sd">            None does not pass the validator. None is only allowed as an</span>
<span class="sd">            initial value and cannot be set after initiation.</span>

<span class="sd">        **kwargs: Passed to InstrumentRefParameter parent class</span>

<span class="sd">    This parameter is useful when one needs a reference to another instrument</span>
<span class="sd">    from within an instrument, e.g., when creating a meta instrument that</span>
<span class="sd">    sets parameters on instruments it contains.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;vals&#39;</span><span class="p">,</span> <span class="n">Strings</span><span class="p">())</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">set_cmd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># TODO(nulinspiratie) check class works now it&#39;s subclassed from Parameter</span>
<div class="viewcode-block" id="InstrumentRefParameter.get_instr"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.InstrumentRefParameter.get_instr">[docs]</a>    <span class="k">def</span> <span class="nf">get_instr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the instance of the instrument with the name equal to the</span>
<span class="sd">        value of this parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_instrument_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="c1"># note that _instrument refers to the instrument this parameter belongs</span>
        <span class="c1"># to, while the ref_instrument_name is the instrument that is the value</span>
        <span class="c1"># of this parameter.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instrument</span><span class="o">.</span><span class="n">find_instrument</span><span class="p">(</span><span class="n">ref_instrument_name</span><span class="p">)</span></div></div>


<span class="c1"># Deprecated parameters</span>
<div class="viewcode-block" id="StandardParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.StandardParameter">[docs]</a><span class="k">class</span> <span class="nc">StandardParameter</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">instrument</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">get_cmd</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">set_cmd</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">set_parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">delay</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_val_age</span><span class="o">=</span><span class="mi">3600</span><span class="p">,</span>
                 <span class="n">vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">val_mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">instrument</span><span class="o">=</span><span class="n">instrument</span><span class="p">,</span>
                         <span class="n">get_cmd</span><span class="o">=</span><span class="n">get_cmd</span><span class="p">,</span> <span class="n">get_parser</span><span class="o">=</span><span class="n">get_parser</span><span class="p">,</span>
                         <span class="n">set_cmd</span><span class="o">=</span><span class="n">set_cmd</span><span class="p">,</span> <span class="n">set_parser</span><span class="o">=</span><span class="n">set_parser</span><span class="p">,</span>
                         <span class="n">post_delay</span><span class="o">=</span><span class="n">delay</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">max_val_age</span><span class="o">=</span><span class="n">max_val_age</span><span class="p">,</span>
                         <span class="n">vals</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span> <span class="n">val_mapping</span><span class="o">=</span><span class="n">val_mapping</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;`StandardParameter` is deprecated, &#39;</span>
                        <span class="s1">&#39;use `Parameter` instead. </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="ManualParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.ManualParameter">[docs]</a><span class="k">class</span> <span class="nc">ManualParameter</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">instrument</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A simple alias for a parameter that does not have a set or</span>
<span class="sd">        a get function. Useful for parameters that do not have a direct</span>
<span class="sd">        instrument mapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">instrument</span><span class="o">=</span><span class="n">instrument</span><span class="p">,</span>
                         <span class="n">get_cmd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">set_cmd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">initial_value</span><span class="o">=</span><span class="n">initial_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="ScaledParameter"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.ScaledParameter">[docs]</a><span class="k">class</span> <span class="nc">ScaledParameter</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameter Scaler</span>

<span class="sd">    To be used when you use a physical voltage divider or an amplifier to set</span>
<span class="sd">    or get a quantity.</span>

<span class="sd">    Initialize the parameter by passing the parameter to be measured/set</span>
<span class="sd">    and the value of the division OR the gain.</span>

<span class="sd">    The scaling value can be either a scalar value or a Qcodes Parameter.</span>

<span class="sd">    The parameter scaler acts a your original parameter, but will set the right</span>
<span class="sd">    value, and store the gain/division in the metadata.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Resistive voltage divider</span>
<span class="sd">        &gt;&gt;&gt; vd = ScaledParameter(dac.chan0, division = 10)</span>

<span class="sd">        Voltage multiplier</span>
<span class="sd">        &gt;&gt;&gt; vb = ScaledParameter(dac.chan0, gain = 30, name = &#39;Vb&#39;)</span>

<span class="sd">        Transimpedance amplifier</span>
<span class="sd">        &gt;&gt;&gt; Id = ScaledParameter(multimeter.amplitude, division = 1e6, name = &#39;Id&#39;, unit = &#39;A&#39;)</span>

<span class="sd">    Args:</span>
<span class="sd">        output: Physical Parameter that need conversion</span>
<span class="sd">        division: the division value</span>
<span class="sd">        gain: the gain value</span>
<span class="sd">        label: label of this parameter, by default uses &#39;output&#39; label</span>
<span class="sd">            but attaches _amplified or _attenuated depending if gain</span>
<span class="sd">            or division has been specified</span>
<span class="sd">        name: name of this parameter, by default uses &#39;output&#39; name</span>
<span class="sd">            but attaches _amplified or _attenuated depending if gain</span>
<span class="sd">            or division has been specified</span>
<span class="sd">        unit: resulting unit. It uses the one of &#39;output&#39; by default</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ScaledParameter.Role"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.ScaledParameter.Role">[docs]</a>    <span class="k">class</span> <span class="nc">Role</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
        <span class="n">GAIN</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
        <span class="n">DIVISION</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">output</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">,</span>
                 <span class="n">division</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">gain</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Set the name</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_scaled&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Set label</span>
        <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="k">elif</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_scaled&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># Set the unit</span>
        <span class="k">if</span> <span class="n">unit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">unit</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span> <span class="o">=</span> <span class="n">output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_instrument</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s2">&quot;_instrument&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Set the role, either as divider or amplifier</span>
        <span class="c1"># Raise an error if nothing is specified</span>
        <span class="n">is_divider</span> <span class="o">=</span> <span class="n">division</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">is_amplifier</span> <span class="o">=</span> <span class="n">gain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">xor</span><span class="p">(</span><span class="n">is_divider</span><span class="p">,</span> <span class="n">is_amplifier</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provide only division OR gain&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_divider</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span> <span class="o">=</span> <span class="n">division</span>
        <span class="k">elif</span> <span class="n">is_amplifier</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span> <span class="o">=</span> <span class="n">gain</span>

        <span class="c1"># extend metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;division&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;gain&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;role&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;wrapped_parameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_instrument</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;wrapped_instrument&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_instrument</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Internal handling of the multiplier</span>
    <span class="c1"># can be either a Parameter or a scalar</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_multiplier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier_parameter</span>

    <span class="nd">@_multiplier</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_multiplier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">multiplier</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier_parameter</span> <span class="o">=</span> <span class="n">multiplier</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;variable_multiplier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier_parameter</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier_parameter</span> <span class="o">=</span> <span class="n">ManualParameter</span><span class="p">(</span>
                <span class="s1">&#39;multiplier&#39;</span><span class="p">,</span> <span class="n">initial_value</span><span class="o">=</span><span class="n">multiplier</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;variable_multiplier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Division of the scaler</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">division</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">()</span>

    <span class="nd">@division</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">division</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">division</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span> <span class="o">=</span> <span class="n">division</span>

    <span class="c1"># Gain of the scaler</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">()</span>

    <span class="nd">@gain</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">=</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span> <span class="o">=</span> <span class="n">gain</span>

    <span class="c1"># Getter and setter for the real value</span>
<div class="viewcode-block" id="ScaledParameter.get_raw"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.ScaledParameter.get_raw">[docs]</a>    <span class="k">def</span> <span class="nf">get_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            value at which was set at the sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_save_val</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">wrapped_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Parameter</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The attached unscaled parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span>

<div class="viewcode-block" id="ScaledParameter.get_wrapped_parameter_value"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.ScaledParameter.get_wrapped_parameter_value">[docs]</a>    <span class="k">def</span> <span class="nf">get_wrapped_parameter_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            value at which the attached parameter is (i.e. does</span>
<span class="sd">            not account for the scaling)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span><span class="o">.</span><span class="n">get</span><span class="p">()</span></div>

<div class="viewcode-block" id="ScaledParameter.set_raw"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.ScaledParameter.set_raw">[docs]</a>    <span class="k">def</span> <span class="nf">set_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value on the wrapped parameter, accounting for the scaling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">GAIN</span><span class="p">:</span>
            <span class="n">instrument_value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ScaledParameter</span><span class="o">.</span><span class="n">Role</span><span class="o">.</span><span class="n">DIVISION</span><span class="p">:</span>
            <span class="n">instrument_value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplier</span><span class="p">()</span>

        <span class="c1"># don&#39;t leak unknow type</span>
        <span class="n">instrument_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">instrument_value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_save_val</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_parameter</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">instrument_value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="expand_setpoints_helper"><a class="viewcode-back" href="../../../api/parameters/parameter.html#qcodes.instrument_drivers.devices.expand_setpoints_helper">[docs]</a><span class="k">def</span> <span class="nf">expand_setpoints_helper</span><span class="p">(</span><span class="n">parameter</span><span class="p">:</span> <span class="n">ParameterWithSetpoints</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">_BaseParameter</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function that takes a :class:`.ParameterWithSetpoints` and</span>
<span class="sd">    acquires the parameter along with it&#39;s setpoints. The data is returned</span>
<span class="sd">    in a format prepared to insert into the dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        parameter: A ParameterWithSetpoints to be acquired and expanded</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of tuples of parameters and values for the specified parameter</span>
<span class="sd">        and its setpoints.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">ParameterWithSetpoints</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="n">f</span><span class="s2">&quot;Expanding setpoints only works for ParameterWithSetpoints. &quot;</span>
            <span class="n">f</span><span class="s2">&quot;Supplied a {type(parameter)}&quot;</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">setpoint_params</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">setpoint_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">setpointparam</span> <span class="ow">in</span> <span class="n">parameter</span><span class="o">.</span><span class="n">setpoints</span><span class="p">:</span>
        <span class="n">these_setpoints</span> <span class="o">=</span> <span class="n">setpointparam</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">setpoint_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">setpointparam</span><span class="p">)</span>
        <span class="n">setpoint_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">these_setpoints</span><span class="p">)</span>
    <span class="n">output_grids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">setpoint_data</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">setpoint_params</span><span class="p">,</span> <span class="n">output_grids</span><span class="p">):</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param</span><span class="p">,</span> <span class="n">grid</span><span class="p">))</span>
    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">parameter</span><span class="p">,</span> <span class="n">parameter</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">res</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>